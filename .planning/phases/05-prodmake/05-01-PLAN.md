---
phase: 05-prodmake
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/convert.h
  - src/main.cpp
autonomous: true

must_haves:
  truths:
    - "prodmake on Rogers-Ramanujan yields a[n]==1 for n≡±1(mod 5) and a[n]==0 otherwise"
    - "prodmake returns std::map<int,Frac> with exponents 1..T-1"
    - "Edge cases (b[0]=0, non-integer a[n]) warn to stderr and return best-effort"
  artifacts:
    - path: src/convert.h
      provides: "prodmake function, Andrews algorithm"
      contains: "std::map<int, Frac> prodmake"
    - path: src/main.cpp
      provides: "Rogers-Ramanujan TEST-01 acceptance"
      contains: "prodmake(rr"
  key_links:
    - from: src/convert.h
      to: src/series.h
      via: "Series::coeff, truncTo"
      pattern: "#include \"series.h\""
    - from: src/convert.h
      to: src/qfuncs.h
      via: "divisors(n) for step 3"
      pattern: "divisors"
    - from: src/main.cpp
      to: src/convert.h
      via: "include and prodmake call"
      pattern: "#include \"convert.h\""
---

<objective>
Implement Andrews' prodmake algorithm and verify Rogers-Ramanujan (TEST-01).

**Purpose:** prodmake is the central acceptance gate. Rogers-Ramanujan (Σ q^(n²)/(q;q)_n → product with denominators at ±1 mod 5) proves the core math is correct.

**Output:** convert.h with prodmake; main.cpp with Rogers-Ramanujan test.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-prodmake/05-CONTEXT.md
@.planning/phases/05-prodmake/05-RESEARCH.md
@src/series.h
@src/qfuncs.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create convert.h with prodmake</name>
  <files>src/convert.h</files>
  <action>
Create src/convert.h with prodmake implementing Andrews' algorithm exactly as in RESEARCH and SPEC §5.1.

**Signature:**
```cpp
std::map<int, Frac> prodmake(const Series& f, int T);
```

**Algorithm (locked):**
1. Extract b[0..T-1] from f. Use effective T = min(T, f.trunc). Truncate: Series g = f.truncTo(T).
2. Normalize: if b[0].isZero() or f.minExp()>0, warn to stderr "prodmake: b[0]=0 or no constant term", return empty std::map. Otherwise divide all coeffs by b[0] (use |b[0]| if b[0]<0 per CONTEXT).
3. Compute c[n] for n=1..T-1: c[n] = n*b[n] - Σ_{j=1}^{n-1} b[n-j]*c[j]. CRITICAL: j runs 1..n-1, NOT 1..n (PITFALLS).
4. Extract a[n] for n=1..T-1: a[n] = (c[n] - Σ_{d|n, d<n} d*a[d]) / n. CRITICAL: divisor sum excludes d=n (PITFALLS). Use: for (int d : divisors(n)) if (d < n) sum += d * a[d].
5. If any a[n] has den != 1 (non-integer), warn to stderr "prodmake: non-integer a[n] at n=...". Return raw a[n] anyway (best-effort per CONTEXT).

**Includes:** #include "series.h", #include "qfuncs.h". Frac and divisors come from those.

**Pitfalls:** Do NOT include d=n in divisor sum; do NOT include j=n in c[n] recurrence.
  </action>
  <verify>g++ -std=c++20 -O2 -o qseries src/main.cpp compiles (main.cpp will include convert.h after Task 2)</verify>
  <done>convert.h exists; prodmake(f,T) returns map; divisor sum excludes d=n; c[n] uses j=1..n-1</done>
</task>

<task type="auto">
  <name>Task 2: Add Rogers-Ramanujan test to main.cpp</name>
  <files>src/main.cpp</files>
  <action>
Add Rogers-Ramanujan acceptance test (TEST-01, SPEC §Acceptance Tests) to main.cpp.

**Steps:**
1. Add #include "convert.h" after qfuncs.h.
2. Add a new test section "--- Phase 5: Rogers-Ramanujan (TEST-01) ---" (e.g. after qfuncs section, before final return).
3. Build Rogers-Ramanujan series: RR = Σ_{n=0}^{8} q^(n²) / (q;q)_n. Use T=50 for series truncation.
   - Series q_var = Series::q(50);
   - Series rr = Series::zero(50);
   - for (int n = 0; n <= 8; ++n) { Series term = q_var.pow(n*n) / aqprod(q_var, q_var, n, 50); rr = rr + term; rr.trunc = 50; } (or equivalent accumulating sum with truncation)
4. Call auto a = prodmake(rr, 50); (T=50 per CONTEXT default; RESEARCH allows 40-50)
5. Verify: for n in 1..49, if n % 5 == 1 or n % 5 == 4 then CHECK(a[n] == Frac(1)), else CHECK(a[n] == Frac(0)).
   - n≡1(mod5) means n%5==1; n≡4(mod5) means n%5==4 (since 4≡-1 mod 5).
   - Only check n where a has a key, or loop 1..min(49, max key in a). For Rogers-Ramanujan, a[n] is 0 for n≢±1 mod 5 — those may be omitted from the map. So: for n=1..49, Frac expected = (n%5==1 || n%5==4) ? Frac(1) : Frac(0); get a[n] via auto it=a.find(n); Frac got = (it!=a.end()) ? it->second : Frac(0); CHECK(got == expected).
6. Spot-check a few: CHECK(a[1]==Frac(1)), CHECK(a[4]==Frac(1)), CHECK(a[2]==Frac(0)) or (a.find(2)==a.end() || a.at(2)==Frac(0)), etc.
  </action>
  <verify>g++ -std=c++20 -O2 -o qseries src/main.cpp && ./qseries exits 0</verify>
  <done>Rogers-Ramanujan test passes; a[n]==1 for n≡±1(mod 5), a[n]==0 otherwise in range 1..49</done>
</task>

</tasks>

<verification>
- Build: g++ -std=c++20 -O2 -o qseries src/main.cpp (or make)
- Run: ./qseries — exits 0, all checks pass
- Rogers-Ramanujan: prodmake on Σ q^(n²)/(q;q)_n (n=0..8, T=50) yields denominators only at 1,4,6,9,11,... ≡ ±1 (mod 5)
</verification>

<success_criteria>
- convert.h prodmake implemented per Andrews algorithm
- Rogers-Ramanujan (TEST-01) passes — a[n]==1 for n≡±1(mod 5), a[n]==0 otherwise
- Divisor sum excludes d=n; c[n] recurrence uses j=1..n-1
</success_criteria>

<output>
After completion, create `.planning/phases/05-prodmake/05-01-SUMMARY.md`
</output>
