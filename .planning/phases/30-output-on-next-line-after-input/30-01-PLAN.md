---
phase: 30-output-on-next-line-after-input
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/repl.h]
autonomous: true

must_haves:
  truths:
    - "REPL output appears on the line after the user's input, not appended to it"
    - "Script mode (non-TTY) unchanged"
  artifacts:
    - path: src/repl.h
      provides: "Newline after readLineRaw return in runRepl"
  key_links:
    - from: runRepl
      to: readLineRaw
      via: "print newline after readLineRaw returns"
---

<objective>
Fix output appearing on same line as input in TTY mode. readLineRaw returns when user presses Enter but does not echo a newline (raw mode). Add std::cout newline after readLineRaw returns in the main REPL loop and in the backslash-continuation loop.

Purpose: Output (series, prodmake, etc.) should appear on the next line after the prompt, not appended to the input line.
Output: Modified src/repl.h — newline after readLineRaw calls.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# runRepl (repl.h ~1038–1048):
# TTY path: cout "qseries> "; auto opt = readLineRaw(env); if (!opt) break; line = *opt;
# readLineRaw is in raw mode — Enter returns the line but does NOT echo \n.
# So display() output starts on the same line as the typed input.
# Fix: after readLineRaw returns a value, print std::cout << std::endl;
# Same issue in continuation loop (~1061–1065): after nextOpt = readLineRaw(env), print newline.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add newline after readLineRaw returns in REPL loop</name>
  <files>src/repl.h</files>
  <action>
In runRepl(), TTY path (around line 1042–1044):
After `auto opt = readLineRaw(env);` and before `if (!opt) break;`:
- Add: `std::cout << std::endl;`
This ensures the newline is printed regardless of whether opt has a value (EOF also gets a clean newline).

In the backslash continuation TTY path (around line 1063–1065):
After `auto nextOpt = readLineRaw(env);` and before `if (!nextOpt) break;`:
- Add: `std::cout << std::endl;`

Two places total. Both in the TTY branches only (non-TTY uses getline which already prints via std::endl on the echo line).
  </action>
  <verify>Build: make or g++ -std=c++20 -O2 -o qseries src/main.cpp. Run interactively: type 1+1, press Enter — output "2" appears on next line, not same line as "qseries> 1+1". All existing acceptance tests still pass.</verify>
  <done>Output appears on the line after input in TTY mode; non-TTY unchanged.</done>
</task>

</tasks>

<verification>
- [ ] TTY: `qseries> 1+1` → Enter → `2` on next line (not `qseries> 1+12`)
- [ ] TTY: multi-line (backslash continuation) → output on next line after final input
- [ ] Non-TTY (script mode): unchanged behavior
- [ ] All existing acceptance tests pass
</verification>

<success_criteria>
- [ ] Output on next line after input in interactive mode
- [ ] No regression in script mode or existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/30-output-on-next-line-after-input/30-01-SUMMARY.md`
</output>
