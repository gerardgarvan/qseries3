---
phase: 28-arrow-key-line-navigation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/repl.h, tests/acceptance-arrow-keys.sh, Makefile]
autonomous: true

must_haves:
  truths:
    - "Left arrow moves cursor left within the input line (when pos > 0)"
    - "Right arrow moves cursor right within the input line (when pos < line.size())"
    - "Typing inserts at cursor; backspace deletes character before cursor"
    - "Tab completion works at cursor position (completes word at cursor)"
    - "Script mode (non-TTY) unchanged — no arrow handling"
  artifacts:
    - path: src/repl.h
      provides: "readLineRaw with cursor position and arrow-key handling"
      contains: "pos"
  key_links:
    - from: readLineRaw
      to: "handleTabCompletion"
      via: "pass pos by reference; completion updates line and pos"
      pattern: "handleTabCompletion\\(.*pos"
---

<objective>
Add left/right arrow-key line navigation in readLineRaw (TTY only). Cursor position is tracked; typing and backspace operate at cursor. Tab completion completes the word at cursor. Script mode (non-TTY) remains unchanged.

Purpose: REPL-OPTS-02 — user can move cursor within input and edit at any position.
Output: Modified src/repl.h with cursor-aware readLineRaw and handleTabCompletion.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-arrow-key-line-navigation/28-CONTEXT.md

# Current readLineRaw (repl.h ~894–921):
# - line, no pos; backspace does line.pop_back(); typing appends; Tab calls handleTabCompletion(line, env)
# handleTabCompletion assumes cursor at end — finds rightmost word.
# CONTEXT: add size_t pos; parse ESC [ D / ESC [ C; redraw on cursor move; backspace at pos-1; insert at pos
# Tab completion at cursor: pass pos, find word ending at pos, complete, update both line and pos
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cursor position and escape-sequence handling</name>
  <files>src/repl.h</files>
  <action>
In readLineRaw:
1. Add `size_t pos = 0` (cursor position: 0 = before first char, line.size() = after last char).
2. Add helper `void redrawLine(const std::string& line, size_t pos)` that: outputs "\r\033[K" + "qseries> " + line, then if pos &lt; line.size() outputs "\033[" + std::to_string(line.size() - pos) + "D" to move cursor left to correct position. Use std::to_string for the count.
3. When c == 27 (ESC): read next char with readOneChar(). If it is '[' (91), read another; if 'D' (68) = left: if pos &gt; 0 { --pos; redrawLine(line, pos); } if 'C' (67) = right: if pos &lt; line.size() { ++pos; redrawLine(line, pos); }. Consume and ignore any other ESC [...] sequence (e.g. Home/End/Delete) to avoid leaving escape bytes in the stream. If first char after ESC is not '[', treat ESC as standalone (e.g. Alt-key) and do nothing.
4. Change backspace (c == 8 || c == 127): if pos &gt; 0 { line.erase(pos - 1, 1); --pos; redrawLine(line, pos); }
5. Change printable (c >= 32 && c <= 126): line.insert(pos, 1, static_cast&lt;char&gt;(c)); ++pos; redrawLine(line, pos) — or output the char and chars after cursor, then move back (simpler: redrawLine after insert)
6. Tab: will be updated in Task 2 to pass pos.

For redrawLine: prompt is "qseries> " (8 chars). After outputting prompt+line, cursor is at end. To move to position pos, move left (line.size() - pos) times. Use "\033[" + count + "D" (cursor backward).
  </action>
  <verify>Build passes. Manually: run qseries, type "hello", left-arrow twice, type "X" — expect "helXlo". Backspace at middle deletes char before cursor.</verify>
  <done>Cursor pos tracked; left/right arrows move cursor; typing and backspace operate at pos; redraw correct.</done>
</task>

<task type="auto">
  <name>Task 2: Make handleTabCompletion cursor-aware</name>
  <files>src/repl.h</files>
  <action>
1. Change signature to `void handleTabCompletion(std::string& line, size_t& pos, const Environment& env)`.
2. Find word containing/ending at cursor: `size_t end = pos; size_t start = end;` then scan backward from start while isalnum/underscore to get start. prefix = line.substr(start, end - start).
3. Rest of logic unchanged (get candidates, match, complete). When completing: line = line.substr(0, start) + match + line.substr(end); pos = start + match.size(); then redrawLine(line, pos). When showing multiple matches: redrawLine(line, pos) at end to restore prompt+line+cursor.
4. In readLineRaw Tab case: call handleTabCompletion(line, pos, env).

Note: handleTabCompletion currently uses "\b \b" to erase and then prints. With cursor anywhere, we must use redrawLine. Add redrawLine as a local lambda or free function visible to both readLineRaw and handleTabCompletion. Define redrawLine before handleTabCompletion so it can be passed in or called — actually redrawLine needs the prompt string "qseries> ". Simplest: define redrawLine as inline function taking (line, pos) and using "qseries> " internally, before handleTabCompletion. handleTabCompletion needs to call it — so either pass redrawLine as a callback or define it in readLineRaw and pass it. Cleaner: define inline void redrawLineRaw(const std::string& line, size_t pos) in repl.h before handleTabCompletion. handleTabCompletion(line, pos, env) then calls redrawLineRaw(line, pos) after modifying line/pos.
  </action>
  <verify>Type "pro" then Tab — completes to prodmake. Type "se" in middle of "seriesX", Tab at cursor — completes word at cursor. Multiple matches still list correctly.</verify>
  <done>Tab completion uses cursor position; completing updates line and pos; redraw correct.</done>
</task>

<task type="auto">
  <name>Task 3: Add acceptance test for arrow-key navigation</name>
  <files>tests/acceptance-arrow-keys.sh, Makefile</files>
  <action>
Create tests/acceptance-arrow-keys.sh:
- Use a small expect-like approach or socat/script to simulate TTY and send arrow keys. On Cygwin/Unix, printf can send escape sequences: left = "\033[D", right = "\033[C".
- Test 1: Send "ab\033[D\033[Dcd" + Enter — expect "acdb" (cursor after 'b', left twice to after 'a', type "cd" → "acdb"). Actually: "ab" then left left puts cursor after 'a'. Typing "cd" gives "acdb". So input "ab" + ESC[D] + ESC[D] + "cd" + newline → "acdb".
- Test 2: Send "hello" + ESC[D] + ESC[D] + backspace (127) + Enter — expect "helo".
- Run via: echo -e 'ab\033[D\033[Dcd' | ./qseries 2>/dev/null | head -5 — but this pipes, so not TTY. Need actual TTY. Use `script` (Unix) or `unbuffer` (expect) to fake TTY. Fallback: If no TTY simulation available on Windows, document manual verification; script can run under Cygwin with script -q -c "commands" if script exists.
- Prefer: Use bash with process substitution or script. Common pattern: script -q -c 'echo -e "ab\033[D\033[Dcd\n" | ./qseries' /dev/null 2>/dev/null | grep -q "acdb" — no, output would be "qseries> acdb" and result. Check that the prompt line contains "acdb".
- Simpler: script -q -c 'printf "ab\033[D\033[Dcd\nquit\n" | timeout 2 ./qseries' /dev/null 2>/dev/null; the REPL doesn't have quit. Use empty line or just exit on EOF. So: printf "ab\033[D\033[Dcd\n\n" | script -q -c './qseries' /dev/null 2>/dev/null. Parse output to verify "acdb" appears on the prompt line.
- Minimal portable test: run under script if available; otherwise skip with "TTY required". In Makefile add target acceptance-arrow-keys that runs the script.

Final: Create acceptance-arrow-keys.sh that (1) checks stdin_is_tty when run interactively, or (2) uses script -q -c 'printf "ab\033[D\033[Dcd\n\n" | ./qseries' /dev/null 2>/dev/null and greps output for "acdb" to verify arrow+edit worked. If script not found, exit 0 with "skipping (script not available)".
- Add Makefile target: acceptance-arrow-keys: ./tests/acceptance-arrow-keys.sh
  </action>
  <verify>make acceptance-arrow-keys passes (or skips gracefully when script unavailable).</verify>
  <done>Acceptance test verifies arrow-key navigation when run in TTY simulation.</done>
</task>

</tasks>

<verification>
- [ ] Left arrow moves cursor left; right arrow moves cursor right
- [ ] Typing inserts at cursor; backspace deletes before cursor
- [ ] Tab completion works at cursor
- [ ] Script mode (echo "1+1" | ./qseries) unchanged — no arrow handling
- [ ] make acceptance-arrow-keys passes or skips
- [ ] Existing acceptance tests still pass
</verification>

<success_criteria>
- [ ] REPL-OPTS-02: Arrow keys move cursor; editing works at cursor
- [ ] TTY only; script mode unchanged
- [ ] Tab completion at cursor remains functional
- [ ] acceptance-arrow-keys.sh passes (or skips if no TTY simulation)
</success_criteria>

<output>
After completion, create `.planning/phases/28-arrow-key-line-navigation/28-01-SUMMARY.md`
</output>
