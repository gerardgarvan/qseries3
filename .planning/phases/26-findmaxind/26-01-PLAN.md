---
phase: 26-findmaxind
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/relations.h
  - src/linalg.h
  - src/repl.h
  - tests/acceptance-findmaxind.sh
autonomous: true

must_haves:
  truths:
    - "findmaxind(L, topshift) returns maximal linearly independent subset and 1-based indices"
    - "Indices match pivot columns of RREF(M^T) per algorithm"
    - "Empty L returns empty subset and empty indices"
  artifacts:
    - path: src/relations.h
      provides: FindmaxindResult, findmaxind(L, topshift)
      contains: "findmaxind"
    - path: src/repl.h
      provides: FindmaxindResult display, dispatch, help
      contains: "findmaxind"
  key_links:
    - from: src/relations.h findmaxind
      to: src/relations.h build_matrix, transpose
      via: M = build_matrix(L, numCols); MT = transpose(M)
      pattern: "build_matrix|transpose"
    - from: src/relations.h findmaxind
      to: src/linalg.h gauss_to_rref
      via: pivot_cols = gauss_to_rref(copy of MT)
      pattern: "gauss_to_rref"
    - from: src/repl.h dispatch
      to: src/relations.h findmaxind
      via: findmaxind(evalListToSeries(args[0]), evi(1))
      pattern: "findmaxind\\("
---

<objective>
Implement findmaxind(L, topshift): find maximal linearly independent subset of q-series in L. Uses RREF on transpose of coefficient matrix; pivot columns = maximal independent indices. Matches Maple findmaxind per GAP-04.

Purpose: Close GAP-04 from FEATURE-GAPS; enable Maple-style determination of rank and independent subset of q-series lists.

Output: findmaxind in relations.h; FindmaxindResult struct; REPL dispatch, display, help; acceptance test.
</objective>

<execution_context>
Execute with fresh context. Build: g++ -std=c++20 -O2 -static -o qseries main.cpp (or make).
</execution_context>

<context>
@.planning/phases/26-findmaxind/26-RESEARCH.md
@.planning/phases/26-findmaxind/26-CONTEXT.md
@src/relations.h
@src/linalg.h
@src/repl.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expose gauss_to_rref and implement findmaxind in relations.h</name>
  <files>src/linalg.h, src/relations.h</files>
  <action>
**linalg.h:** Move gauss_to_rref out of anonymous namespace so relations.h can call it. Change:
- Remove the `namespace { ... }` wrapper around gauss_to_rref.
- Keep gauss_to_rref as inline at file scope (same as kernel, solve).
- Signature: `inline std::vector&lt;int&gt; gauss_to_rref(std::vector&lt;std::vector&lt;Frac&gt;&gt;&amp; A, int maxCols = -1)`

**relations.h:** Add after transpose (around line 58), before findhom.

1. Define result struct: `struct FindmaxindResult { std::vector&lt;Series&gt; subset; std::vector&lt;int&gt; indices; };`

2. Implement findmaxind: `inline FindmaxindResult findmaxind(const std::vector&lt;Series&gt;&amp; L, int topshift)`
   - If L.empty(): return {{}, {}}
   - T = min trunc over L
   - numCols = T + topshift; if numCols &lt;= 0 return {{}, {}}
   - M = build_matrix(L, numCols)  // rows=series, cols=q-powers
   - MT = transpose(M)             // rows=q-powers, cols=series
   - MT_copy = MT (copy)
   - pivot_cols = gauss_to_rref(MT_copy)  // pivot cols = independent series indices (0-based)
   - subset: for each i in pivot_cols, push L[i]
   - indices: for each i in pivot_cols, push i+1 (1-based, Maple compatible)
   - return {subset, indices}
  </action>
  <verify>Build succeeds. In REPL: L := [etaq(1,50), etaq(2,50), etaq(1,50)]; findmaxind(L,0) — etaq(1) and etaq(2) are independent, duplicate etaq(1) is dependent; expect indices [1,2] or [1,3] depending on RREF order.</verify>
  <done>findmaxind exists in relations.h; returns FindmaxindResult with subset and 1-based indices; uses build_matrix, transpose, gauss_to_rref.</done>
</task>

<task type="auto">
  <name>Task 2: EvalResult type, format, display, dispatch, help in repl.h</name>
  <files>src/repl.h</files>
  <action>
1. Add FindmaxindResult to EvalResult variant (after CheckmultResult, ~line 135). repl.h already includes relations.h.

2. Add formatFindmaxind(FindmaxindResult r): build string "indices: [1, 2, 3, ...]" for r.indices, append " (" + count + " of " + total + " independent)" if useful. E.g. "indices: [1, 2, 4, 6] (4 of 8 independent)". Keep concise.

3. In display() visitor: add case for FindmaxindResult calling formatFindmaxind. Optionally print subset series (one per line) if count is small (e.g. &lt;=5); otherwise just indices. Simpler: output indices only per Maple primary output.

4. In dispatchBuiltin: findmaxind — args.size()==2: L = evalListToSeries(args[0]), topshift = static_cast&lt;int&gt;(evi(1)); return findmaxind(L, topshift); else throw "findmaxind(L, topshift) expects 2 arguments".

5. In getHelpTable(): {"findmaxind", {"findmaxind(L, topshift)", "maximal linearly independent subset of q-series in L; returns indices (1-based)"}}
  </action>
  <verify>Build succeeds. REPL: L := [etaq(1,50), etaq(2,50)]; findmaxind(L,0) prints indices. help(findmaxind) shows correct entry.</verify>
  <done>findmaxind built-in works; display shows indices; help(findmaxind) works.</done>
</task>

<task type="auto">
  <name>Task 3: Acceptance test for findmaxind</name>
  <files>tests/acceptance-findmaxind.sh</files>
  <action>
Create tests/acceptance-findmaxind.sh:

1. Same BIN resolution as acceptance-checkprod-checkmult.sh: dist/qseries.exe, dist/qseries, qseries.exe, qseries.

2. run() helper: printf inputs | "$BIN" 2&gt;&amp;1

3. Test 1 — Independent list: L = [etaq(1,50), etaq(2,50), etaq(3,50)] — three eta products are typically independent. findmaxind(L,0). Expect output containing "indices" and three indices (e.g. [1, 2, 3]).

4. Test 2 — Dependent list: L = [etaq(1,50), etaq(1,50)] — duplicate. findmaxind(L,0). Expect indices [1] or [2] (one index, one independent).

5. Test 3 — Rogers-Ramanujan basis: Build list of G1, G2 (two RR series). findmaxind should return 2 indices. Use: g1 := sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8); g2 := sum(q^(n*(n+1))/aqprod(q,q,n,50), n, 0, 8); L := [g1, g2]; findmaxind(L,0). Expect 2 independent.

6. Make executable (chmod +x) and run.
  </action>
  <verify>./tests/acceptance-findmaxind.sh exits 0; all tests pass.</verify>
  <done>Acceptance test passes; findmaxind behaves per Maple semantics.</done>
</task>

</tasks>

<verification>
- Build: make or g++ -std=c++20 -O2 -o qseries main.cpp
- Independent list: findmaxind([etaq(1,50), etaq(2,50), etaq(3,50)], 0) → 3 indices
- Duplicate list: findmaxind([etaq(1,50), etaq(1,50)], 0) → 1 index
- Rogers-Ramanujan G1,G2: findmaxind([g1,g2], 0) → 2 indices
</verification>

<success_criteria>
- findmaxind(L, topshift) works; returns FindmaxindResult with subset and 1-based indices
- Algorithm: M = build_matrix(L, T+topshift), MT = transpose(M), pivot_cols = gauss_to_rref(copy(MT)), subset = L[pivot_cols], indices = pivot_cols+1
- Display shows indices (and optionally subset)
- help(findmaxind) shows signature and description
- tests/acceptance-findmaxind.sh exits 0
</success_criteria>

<output>
After completion, create .planning/phases/26-findmaxind/26-01-SUMMARY.md
</output>
