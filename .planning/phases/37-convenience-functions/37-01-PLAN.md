---
phase: 37-convenience-functions
plan: 01
status: COMPLETED
estimated_duration: ~15min
---

## Goal

Add 4 convenience built-ins to the REPL: `coeff`, `dissect`, `jacobi`, `kronecker`.

## Requirements Traced

- MATH-04: `coeff(f, n)` — extract single coefficient
- MATH-05: `dissect(f, m, T)` — return all m siftings
- MATH-06: `jacobi(a, n)` — Jacobi symbol
- MATH-07: `kronecker(a, n)` — Kronecker symbol
- MATH-11: All existing acceptance tests still pass

## Analysis

### coeff(f, n)

- `Series::coeff(int n)` already exists, returns `Frac`
- Dispatch: call `ev(0).coeff(static_cast<int>(evi(1)))`, print via `Frac::str()`, return `DisplayOnly{}`
- Display: bare rational like `3/2` or integer like `5` (no O-term, no series formatting)

### dissect(f, m, T)

- `sift(f, n, k, T)` already exists in `convert.h`
- dissect(f, m, T) = print sift(f, m, k, T) for k = 0..m-1
- Display: print each component labeled `k=0: ...`, `k=1: ...`, etc.
- Return `DisplayOnly{}` (multiple series, not a single result)

### jacobi(a, n)

- `legendre(a, p)` exists for prime p; Jacobi extends to composite odd n
- Implementation: factor n into primes, compute product of Legendre symbols
- New function `jacobi(int64_t a, int64_t n)` in `qfuncs.h`
- Edge cases: n must be odd positive; jacobi(0, n) = 0 if gcd(a,n)>1; jacobi(a, 1) = 1

### kronecker(a, n)

- Extends Jacobi to all integers n (even, negative, zero)
- Definition: kronecker(a, 0) = 1 if |a|=1, else 0; kronecker(a, -1) = -1 if a<0, else 1; for n=2: lookup table based on a mod 8
- For general n: factor out sign, powers of 2, then use Jacobi for odd part
- New function `kronecker(int64_t a, int64_t n)` in `qfuncs.h`

## Tasks

### Task 1: Add jacobi() and kronecker() to qfuncs.h

**File:** `src/qfuncs.h`

After the existing `legendre` function (line ~58), add:

```cpp
inline int jacobi(int64_t a, int64_t n) {
    if (n <= 0 || n % 2 == 0) return 0; // Jacobi only defined for odd positive n
    if (n == 1) return 1;
    a = a % n;
    if (a < 0) a += n;
    if (a == 0) return 0;
    int result = 1;
    while (a != 0) {
        while (a % 2 == 0) {
            a /= 2;
            if (n % 8 == 3 || n % 8 == 5) result = -result;
        }
        std::swap(a, n);
        if (a % 4 == 3 && n % 4 == 3) result = -result;
        a = a % n;
    }
    return (n == 1) ? result : 0;
}

inline int kronecker(int64_t a, int64_t n) {
    if (n == 0) return (a == 1 || a == -1) ? 1 : 0;
    int result = 1;
    if (n < 0) {
        n = -n;
        if (a < 0) result = -result;
    }
    // Extract factor of 2
    int twos = 0;
    while (n % 2 == 0) { n /= 2; ++twos; }
    if (twos > 0) {
        int64_t a8 = ((a % 8) + 8) % 8;
        if (a % 2 == 0) return 0; // (even/2) = 0
        // kronecker(a, 2) = 0 if a even, 1 if a ≡ ±1 mod 8, -1 if a ≡ ±3 mod 8
        int kr2 = (a8 == 1 || a8 == 7) ? 1 : -1;
        for (int i = 0; i < twos; ++i) result *= kr2;
    }
    if (n == 1) return result;
    return result * jacobi(a, n);
}
```

### Task 2: Add help entries to getHelpTable()

**File:** `src/repl.h`

Add in alphabetical position within the help table:

```cpp
{"coeff", {"coeff(f,n)", "coefficient of q^n in series f"}},
{"dissect", {"dissect(f,m,T)", "list all m siftings of f: sift(f,m,k,T) for k=0..m-1"}},
{"jacobi", {"jacobi(a,n)", "Jacobi symbol (a/n) for odd positive n"}},
{"kronecker", {"kronecker(a,n)", "Kronecker symbol (a/n) for all integer n"}},
```

### Task 3: Add dispatch handlers in dispatchBuiltin()

**File:** `src/repl.h`

Near the existing `legendre`/`sigma` handlers:

```cpp
if (name == "coeff") {
    if (args.size() != 2)
        throw std::runtime_error(runtimeErr(name, "expects 2 arguments"));
    Frac c = ev(0).coeff(static_cast<int>(evi(1)));
    std::cout << c.str() << std::endl;
    return DisplayOnly{};
}
if (name == "dissect") {
    if (args.size() != 3)
        throw std::runtime_error(runtimeErr(name, "expects 3 arguments"));
    Series f = ev(0);
    int m = static_cast<int>(evi(1));
    int Td = static_cast<int>(evi(2));
    for (int k = 0; k < m; ++k) {
        Series s = sift(f, m, k, Td);
        std::cout << "k=" << k << ": " << s.str(30) << std::endl;
    }
    return DisplayOnly{};
}
if (name == "jacobi") {
    if (args.size() != 2)
        throw std::runtime_error(runtimeErr(name, "expects 2 arguments"));
    return static_cast<int64_t>(jacobi(evi(0), evi(1)));
}
if (name == "kronecker") {
    if (args.size() != 2)
        throw std::runtime_error(runtimeErr(name, "expects 2 arguments"));
    return static_cast<int64_t>(kronecker(evi(0), evi(1)));
}
```

### Task 4: Build, test, verify

1. Build: `make clean && make`
2. Smoke test all 4 functions:
   - `coeff(etaq(1,30), 5)` → `-1` (pentagonal: coefficient of q^5 in Euler's product)
   - `dissect(etaq(1,30), 3, 10)` → 3 sifted series
   - `jacobi(2, 15)` → `1` (2 is QR mod 3 and mod 5)
   - `kronecker(2, 6)` → `0` (gcd(2,6)>1)
   - `kronecker(-1, -1)` → `-1`
3. All existing acceptance tests pass

## Verification Criteria

- [ ] `coeff(etaq(1,30), 5)` returns correct value
- [ ] `dissect(f, 5, T)` returns 5 labeled siftings
- [ ] `jacobi(2, 15)` returns `1`
- [ ] `kronecker(a, n)` works for even, negative, zero n
- [ ] `help(coeff)`, `help(dissect)`, `help(jacobi)`, `help(kronecker)` work
- [ ] All existing acceptance tests pass

## Risk Assessment

- **Low risk**: `coeff` and `dissect` are thin wrappers over existing code
- **Medium risk**: `jacobi` algorithm (quadratic reciprocity loop) must be correct — verified against known values
- **Low risk**: `kronecker` builds on `jacobi` with 2-adic and sign extensions
