---
phase: 38-math-enrichment
plan: 01
status: COMPLETED
estimated_duration: ~15min
---

## Goal

Add 3 math enrichment built-ins to the REPL: `eisenstein`, `partition`, `qdiff`.

## Requirements Traced

- MATH-08: `eisenstein(k, T)` — normalized Eisenstein series E_{2k}(q)
- MATH-09: `partition(n)` — partition number p(n)
- MATH-10: `qdiff(f)` — formal q-derivative
- MATH-11: All existing acceptance tests still pass

## Analysis

### eisenstein(k, T)

The normalized Eisenstein series of weight 2k:

    E_{2k}(q) = 1 - (4k / B_{2k}) Σ_{n=1}^{T-1} σ_{2k-1}(n) q^n

where B_{2k} are Bernoulli numbers.

**Implementation approach:**
- Hardcode Bernoulli numbers B_2 through B_20 as Frac(num, den)
- Compute the multiplier `c = Frac(-4*k) / B_{2k}` (exact rational)
- For each n=1..T-1, compute σ_{2k-1}(n) using BigInt to avoid int64_t overflow for large k
- Build Series with Frac coefficients

**Bernoulli table:** B_2=1/6, B_4=-1/30, B_6=1/42, B_8=-1/30, B_10=5/66, B_12=-691/2730, B_14=7/6, B_16=-3617/510, B_18=43867/798, B_20=-174611/330

**Verification:** `eisenstein(2, 50)` = E_4 = 1 + 240q + 2160q² + ...

### partition(n)

Compute partition number p(n) using existing infrastructure:

    p(n) = coeff of q^n in 1/etaq(1, n+1)

This reuses the pentagonal-optimized `etaq(1, T)` and `Series::inverse()`.

**Return type:** Display as string via Frac::str() (always integer) using `DisplayOnly{}`.

**Verification:** `partition(100)` = 190569292

### qdiff(f)

The formal q-derivative θ_q f = q · d/dq f:

    If f = Σ a_n q^n, then qdiff(f) = Σ n · a_n · q^n

Simply multiply each coefficient by its exponent. O(T), trivial.

**Return type:** Series (stored in env, composable with other operations).

**Verification:** `qdiff(1 + q + q^2 + q^3)` = q + 2q² + 3q³

## Tasks

### Task 1: Add eisenstein() to qfuncs.h

**File:** `src/qfuncs.h`

After the `euler_phi` function, add:

```cpp
inline Frac bernoulli_even(int n) {
    static const std::pair<int64_t, int64_t> table[] = {
        {1, 6},           // B_2
        {-1, 30},         // B_4
        {1, 42},          // B_6
        {-1, 30},         // B_8
        {5, 66},          // B_10
        {-691, 2730},     // B_12
        {7, 6},           // B_14
        {-3617, 510},     // B_16
        {43867, 798},     // B_18
        {-174611, 330},   // B_20
    };
    int idx = n / 2 - 1;
    if (idx < 0 || idx >= 10)
        throw std::runtime_error("eisenstein: k too large (max k=10)");
    return Frac(table[idx].first, table[idx].second);
}

inline Series eisenstein(int k, int T) {
    if (k < 1) throw std::runtime_error("eisenstein: k must be >= 1");
    Frac B = bernoulli_even(2 * k);
    Frac multiplier = Frac(-4 * k) / B;
    Series result;
    result.trunc = T;
    result.setCoeff(0, Frac(1));
    for (int n = 1; n < T; ++n) {
        // σ_{2k-1}(n) using Frac to avoid int64_t overflow
        Frac s(0);
        for (int d : divisors(n)) {
            Frac df(d);
            Frac term(1);
            for (int i = 0; i < 2 * k - 1; ++i) term = term * df;
            s = s + term;
        }
        result.setCoeff(n, multiplier * s);
    }
    return result;
}
```

### Task 2: Add partition() and qdiff() to qfuncs.h

**File:** `src/qfuncs.h`

After the `eisenstein` function:

```cpp
inline Frac partition_number(int n) {
    if (n < 0) return Frac(0);
    if (n == 0) return Frac(1);
    Series eta = etaq(1, n + 1);
    Series gen = eta.inverse();
    return gen.coeff(n);
}

inline Series qdiff(const Series& f) {
    Series result;
    result.trunc = f.trunc;
    for (const auto& [e, v] : f.c) {
        if (e != 0 && e < f.trunc)
            result.setCoeff(e, v * Frac(e));
    }
    return result;
}
```

### Task 3: Add help entries + dispatch handlers in repl.h

**File:** `src/repl.h`

Help entries (alphabetical):
```cpp
{"eisenstein", {"eisenstein(k,T)", "normalized Eisenstein series E_{2k}(q)"}},
{"partition", {"partition(n)", "partition number p(n)"}},
{"qdiff", {"qdiff(f)", "q-derivative θ_q f = q·d/dq f = Σ n·a_n·q^n"}},
```

Dispatch handlers:
```cpp
if (name == "eisenstein") {
    if (args.size() != 2)
        throw std::runtime_error(runtimeErr(name, "expects 2 arguments"));
    return eisenstein(static_cast<int>(evi(0)), static_cast<int>(evi(1)));
}
if (name == "partition") {
    if (args.size() != 1)
        throw std::runtime_error(runtimeErr(name, "expects 1 argument"));
    Frac p = partition_number(static_cast<int>(evi(0)));
    std::cout << p.str() << std::endl;
    return DisplayOnly{};
}
if (name == "qdiff") {
    if (args.size() != 1)
        throw std::runtime_error(runtimeErr(name, "expects 1 argument"));
    return qdiff(ev(0));
}
```

### Task 4: Build, test, verify

1. Build: `make clean && make`
2. Smoke test all 3 functions
3. All existing acceptance tests pass

## Verification Criteria

- [ ] `eisenstein(2, 50)` returns 1 + 240q + 2160q² + ...
- [ ] `eisenstein(1, 20)` returns E_2 = 1 - 24q - 72q² - ...
- [ ] `partition(100)` returns 190569292
- [ ] `partition(0)` returns 1, `partition(1)` returns 1
- [ ] `qdiff(1 + q + q^2 + q^3)` returns q + 2q² + 3q³
- [ ] All existing acceptance tests pass

## Risk Assessment

- **Low risk**: `qdiff` is trivial
- **Low risk**: `partition` reuses existing optimized infrastructure
- **Medium risk**: `eisenstein` — Bernoulli table must be correct; σ computation using Frac is slower but exact
