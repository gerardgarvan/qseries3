---
phase: 19-multi-line-input
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/repl.h
autonomous: true

must_haves:
  truths:
    - "Backslash at end of line continues on next line"
    - "REPL prompts for continuation until complete"
    - "Backslash-newline treated as whitespace; parses as single unit"
  artifacts:
    - path: src/repl.h
      provides: runRepl with multi-line read loop
---

<objective>
Add backslash continuation to runRepl(): when a line ends with backslash, strip it, show continuation prompt, read next line, append with space, repeat until line does not end with backslash. Then parse the combined string. Use continuation prompt (e.g. "  > ") when reading more lines. Enforce max continuation lines (e.g. 100) to avoid infinite loop. Works in both interactive and script mode.

Purpose: QOL-05
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/19-multi-line-input/19-CONTEXT.md
@.planning/phases/19-multi-line-input/19-RESEARCH.md
@src/repl.h
</context>

<tasks>

<task type="auto">
  <name>Add backslash continuation loop in runRepl</name>
  <files>src/repl.h</files>
  <action>
1. In runRepl(), replace the single getline with a continuation loop:
   - Read first line with getline (as now). If EOF, break.
   - In a loop: trim the line; while the trimmed line ends with '\\' (and size > 0):
     - Remove the trailing backslash (and optional trailing spaces) from line
     - Show continuation prompt: if stdin_is_tty() print "  > " << flush; else echo "  > " + next_line when we get it
     - If !getline(next), break outer (incomplete input — could treat as-is or error; prefer use what we have)
     - Append " " + next to line
     - Enforce max continuation count (e.g. 100) to avoid infinite loop
   - Then use `line` (the accumulated string) for the rest: trim, parse, etc.

2. When not TTY (script mode): after getline in continuation, echo "  > " + next_line (match current behavior for command echo). Or simplify: only echo when we're about to add a continuation line, similar to "qseries> " + line for first line.

3. Replace backslash+newline with space: the accumulated line has spaces between continued parts. Parser receives one logical line.

4. Continuation prompt: use "  > " (two spaces + greater-than) per CONTEXT "whatever works best" — distinguishes from main "qseries> ".
  </action>
  <verify>
- "1 + \\" + newline + "1" → evaluates to 2
- "etaq(1,\\" + "100)" → parses as etaq(1,100)
- In script: echo -e "q + q^2\\\n+ q^3" | qseries → parses and evaluates
  </verify>
  <done>Backslash continuation works; REPL prompts for more until complete.</done>
</task>

</tasks>

<verification>
- Build succeeds
- Backslash at EOL continues
- Continuation prompt shown when interactive
- Multi-line expression parses as single unit
</verification>

<success_criteria>
1. User can end line with backslash to continue on next line
2. REPL prompts for continuation until expression complete
3. Backslash-newline treated as whitespace; parses as single unit
</success_criteria>

<output>
After completion, create `.planning/phases/19-multi-line-input/19-01-SUMMARY.md`
</output>
