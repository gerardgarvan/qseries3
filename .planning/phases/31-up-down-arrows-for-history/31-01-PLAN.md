---
phase: 31-up-down-arrows-for-history
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/repl.h, tests/acceptance-history.sh]
autonomous: true

must_haves:
  truths:
    - "Up arrow recalls the previous command into the input line"
    - "Repeated up arrows walk backwards through history (most recent first)"
    - "Down arrow walks forward through history toward current line"
    - "Down arrow past newest history entry restores the original in-progress line"
    - "Recalled line places cursor at end of line"
    - "History navigation works correctly with backslash continuation input"
  artifacts:
    - path: "src/repl.h"
      provides: "readLineRaw with history navigation"
      contains: "readLineRaw(Environment& env, const std::deque<std::string>& history)"
    - path: "tests/acceptance-history.sh"
      provides: "Acceptance test for up/down arrow history"
  key_links:
    - from: "readLineRaw"
      to: "runRepl history deque"
      via: "const reference parameter"
      pattern: "readLineRaw\\(env, history\\)"
---

<objective>
Add up/down arrow key support for navigating command history in the REPL's raw terminal input.

Purpose: Users can recall and re-execute previous commands without retyping.
Output: Modified readLineRaw with history navigation + acceptance test.
</objective>

<execution_context>
@.planning/phases/31-up-down-arrows-for-history/31-RESEARCH.md
</execution_context>

<context>
@.planning/STATE.md
@src/repl.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add history parameter and up/down arrow handling to readLineRaw</name>
  <files>src/repl.h</files>
  <action>
  1. Change `readLineRaw` signature from `readLineRaw(Environment& env)` to `readLineRaw(Environment& env, const std::deque<std::string>& history)`.

  2. Add two local variables at the top of readLineRaw, after `size_t pos = 0;`:
     - `size_t histIdx = history.size();` (starts past end = "current line")
     - `std::string savedLine;` (saves in-progress input before first up-arrow)

  3. Inside the ESC [ handler (after `int c3 = readOneChar();`), add two branches BEFORE the existing left/right branches:

     ```cpp
     if (c3 == 65) {  // up arrow
         if (!history.empty() && histIdx > 0) {
             if (histIdx == (int)history.size()) savedLine = line;
             --histIdx;
             line = history[histIdx];
             pos = line.size();
             redrawLineRaw(line, pos);
         }
     } else if (c3 == 66) {  // down arrow
         if (histIdx < history.size()) {
             ++histIdx;
             line = (histIdx == history.size()) ? savedLine : history[histIdx];
             pos = line.size();
             redrawLineRaw(line, pos);
         }
     } else if (c3 == 68) {  // left (existing)
     ```

  4. Update both call sites in `runRepl()`:
     - Line ~1042: `readLineRaw(env)` → `readLineRaw(env, history)`
     - Line ~1064: `readLineRaw(env)` → `readLineRaw(env, history)`
  </action>
  <verify>
  Build succeeds: `g++ -std=c++20 -O2 -o dist/qseries.exe src/main.cpp`
  All existing acceptance tests pass: `make acceptance`
  </verify>
  <done>Up/down arrow keys navigate history in REPL; cursor lands at end of recalled line; down past newest restores saved line; existing left/right/Tab/backspace still work.</done>
</task>

<task type="auto">
  <name>Task 2: Create acceptance test for history navigation</name>
  <files>tests/acceptance-history.sh</files>
  <action>
  Create `tests/acceptance-history.sh` that validates history navigation via piped escape sequences.

  Test cases (pipe raw bytes including ESC sequences):
  1. Enter "1+1", press Enter, then press Up arrow (ESC [ A) + Enter — output should show result of "1+1" again (value 2).
  2. Enter "2+2", Enter, "3+3", Enter, then Up (should recall "3+3"), Up again (should recall "2+2"), Down (should recall "3+3"), Enter — output should show 6.

  Use printf to send ESC sequences: `\x1b[A` for up, `\x1b[B` for down.

  Since readLineRaw is only used in TTY mode and piped input uses getline, use a PTY-based approach consistent with the existing acceptance-arrow-keys.sh test. Check that file for the pattern — if it uses `script` or `expect` or Python pty, follow the same approach.

  Add a Makefile target `acceptance-history` that runs this test.
  </action>
  <verify>`bash tests/acceptance-history.sh` passes (exit 0)</verify>
  <done>Acceptance test confirms up/down history navigation works correctly via automated PTY input.</done>
</task>

</tasks>

<verification>
1. `g++ -std=c++20 -O2 -o dist/qseries.exe src/main.cpp` succeeds
2. `make acceptance` — all existing tests pass (no regressions)
3. `bash tests/acceptance-history.sh` — history navigation test passes
4. Manual verification: launch `./dist/qseries.exe`, type a few commands, press Up/Down to navigate history, confirm cursor lands at end of recalled line and editing works
</verification>

<success_criteria>
- Up arrow recalls previous command (most recent first)
- Repeated up arrows walk backwards through full history
- Down arrow walks forward; past newest entry restores in-progress text
- Cursor positioned at end of recalled line
- Build succeeds, all acceptance tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-up-down-arrows-for-history/31-01-SUMMARY.md`
</output>
