---
phase: 27-suppress-output-semicolon
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/repl.h]
autonomous: true

must_haves:
  truths:
    - "User can type `rr := sum(...):` and result is stored but not printed"
    - "User can type `etaq(1,50):` and evaluation runs without printing result"
    - "Without trailing colon, result is printed as before"
    - "Trailing colon works for both assignments and expression statements"
  artifacts:
    - path: src/repl.h
      provides: "REPL loop with colon-based output suppression"
      contains: "suppress_output"
  key_links:
    - from: runRepl
      to: "parse"
      via: "pass trimmed string (without trailing colon) to parse"
      pattern: "parse\\( trimmed"
---

<objective>
Add Maple-style output suppression: trailing colon on a statement suppresses result printing. `rr := sum(...):` stores without printing; `etaq(1,50):` evaluates without printing. REPL-layer only — no parser or tokenizer changes.

Purpose: REPL-OPTS-01 — user can suppress verbose output when loading scripts or building up variables.
Output: Modified src/repl.h with colon detection and display-skip logic.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-suppress-output-semicolon/27-CONTEXT.md

# REPL loop flow (src/repl.h ~1036–1055):
# - Read line, backslash continuation, trim
# - parse(trimmed), eval, display(res), timing
# CONTEXT decisions: REPL-layer only; check last char == ':'; strip colon before parse; skip display + timing when suppress_output
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add trailing-colon detection and suppress_output flag</name>
  <files>src/repl.h</files>
  <action>
After `std::string trimmed = trim(line);` and the empty check, add logic:
1. bool suppress_output = false;
2. if (!trimmed.empty() && trimmed.back() == ':') { trimmed.pop_back(); trim again if needed (rtrim trailing spaces after colon); suppress_output = true; }
3. If trimmed becomes empty after stripping colon (e.g. user typed just ":"), treat as empty line: continue.

Then pass `trimmed` (without trailing colon) to `parse(trimmed)` as usual. Store `suppress_output` for use after eval.

Note: Assignment uses `:=`. Only a *trailing* colon after the whole statement suppresses output. The `:=` in the middle is unchanged — we only strip a colon that appears at the very end of the trimmed line.
  </action>
  <verify>Build passes: make or g++ -std=c++20 -O2 -o qseries main.cpp</verify>
  <done>Trailing colon is stripped before parse; suppress_output is set; `x := 1:` parses as `x := 1` and suppress_output=true.</done>
</task>

<task type="auto">
  <name>Task 2: Skip display and timing when suppress_output is true</name>
  <files>src/repl.h</files>
  <action>
In the REPL try block, after eval:
- if (std::holds_alternative&lt;std::monostate&gt;(res)) continue;  // unchanged
- if (suppress_output) { /* skip display and timing */ continue; }
- Otherwise: display(res, env, env.T); then timing output (unchanged).

When suppress_output is true, do NOT call display() and do NOT print the elapsed time. The result is still evaluated and stored (e.g. assignment updates env); only the output is suppressed.
  </action>
  <verify>Interactive test: `x := 1:` produces no output; `x` prints 1. `etaq(1,10):` produces no output.</verify>
  <done>Trailing-colon statements evaluate but produce no displayed output or timing line.</done>
</task>

<task type="auto">
  <name>Task 3: Add acceptance test for suppress output</name>
  <files>tests/acceptance-suppress-output.sh</files>
  <action>
Create tests/acceptance-suppress-output.sh that:
1. Runs qseries with piped input (script mode)
2. Sends: `x := 1:` then `series(x,5)` — expects series output (x was stored)
3. Sends: `etaq(1,10):` then `series(etaq(1,10),10)` — expects series output (etaq was run, next line confirms)
4. Verifies no output appears after the colon lines (only after the non-colon lines)

Use echo/printf to pipe commands. Check that output lines match expected pattern (no stray lines from colon statements).

Add Makefile target: acceptance-suppress-output
  </action>
  <verify>make acceptance-suppress-output passes</verify>
  <done>Acceptance test verifies colon suppresses output for assignments and expressions.</done>
</task>

</tasks>

<verification>
- [ ] `x := 1:` stores 1, no output
- [ ] `etaq(1,50):` evaluates, no output
- [ ] `x := 1` (no colon) prints result
- [ ] `x := 1 :` (space before colon) suppresses per CONTEXT
- [ ] All existing acceptance tests still pass
</verification>

<success_criteria>
- [ ] REPL-OPTS-01: User can suppress output by ending statement with colon
- [ ] Works for assignments and expressions
- [ ] No parser changes; detection and display-skip in REPL only
- [ ] acceptance-suppress-output.sh passes
</success_criteria>

<output>
After completion, create `.planning/phases/27-suppress-output-semicolon/27-01-SUMMARY.md`
</output>
