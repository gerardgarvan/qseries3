---
phase: 02-frac
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/frac.h]
autonomous: true

must_haves:
  truths:
    - "6/4 reduces to 3/2; 0/5 reduces to 0/1"
    - "reduce() runs after every construction and operation"
    - "Frac(n,0) and a/b when b zero throw std::invalid_argument"
    - "add/sub/mul/div produce correct reduced results with sign handling"
    - "den > 0 and gcd(|num|,den)=1 after reduce; zero stored as 0/1"
  artifacts:
    - path: src/frac.h
      provides: Frac struct, reduce, arithmetic ops, comparisons, str
      contains: "struct Frac"
  key_links:
    - from: "Frac::reduce"
      to: "bigGcd"
      via: "include bigint.h and call bigGcd(num.abs(), den)"
      pattern: "bigGcd"
---

<objective>
Implement src/frac.h with exact rational arithmetic. Auto-reduce via GCD in every constructor and operator. Throw on zero denominator. Per SPEC and RESEARCH: den > 0, gcd(|num|,den)=1, 0/1 for zero.
</objective>

Purpose: Foundation for Series (Phase 3). Frac must produce no exponential BigInt growth — strict per-op reduce() is non-negotiable.
Output: src/frac.h with Frac struct, reduce(), constructors, +,-,*,/, comparisons, str().

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-frac/02-CONTEXT.md
@.planning/phases/02-frac/02-RESEARCH.md
@SPEC.md
@.cursorrules
@src/bigint.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Frac struct, constructors, reduce, helpers</name>
  <files>src/frac.h</files>
  <action>
Create src/frac.h (guard: FRAC_H). Include "bigint.h".

1. **struct Frac** with `BigInt num, den`. Per .cursorrules: struct with methods, no virtual.

2. **Constructors** (call reduce() at end of each):
   - `Frac()` — 0/1
   - `Frac(int64_t n)` — n/1
   - `Frac(int64_t n, int64_t d)` — validate d != 0 before reduce
   - `Frac(BigInt n, BigInt d)` — validate d.isZero(), throw std::invalid_argument before reduce

3. **void reduce()** (per RESEARCH code example):
   - If den.isZero() → throw std::invalid_argument("Frac: denominator zero")
   - If den < 0 → num = -num, den = -den
   - If num.isZero() → den = 1, return
   - g = bigGcd(num.abs(), den); num /= g; den /= g

4. **Helpers**: isZero(), isOne(), abs()

Use std::invalid_argument for consistency with BigInt (per RESEARCH Open Questions).
</action>
  <verify>Frac(6,4).num == 3 && Frac(6,4).den == 2; Frac(0,5).num == 0 && Frac(0,5).den == 1; Frac(1,0) throws</verify>
  <done>Constructors and reduce produce 6/4→3/2, 0/5→0/1; Frac(n,0) throws</done>
</task>

<task type="auto">
  <name>Task 2: Arithmetic operators and comparisons</name>
  <files>src/frac.h</files>
  <action>
Add to frac.h:

1. **Arithmetic** — each returns Frac (ctor calls reduce): operator-(), operator+, operator-, operator*, operator/
   - Addition: (a*d + c*b) / (b*d)
   - Subtraction: (a*d - c*b) / (b*d)
   - Multiplication: (a*c) / (b*d)
   - Division: if o.isZero() throw std::invalid_argument; (a*d) / (b*c) — multiply by reciprocal

2. **Comparison**: operator==, operator!=, operator<, operator<=, operator>, operator>=
   - Cross-multiply for <: a/b < c/d iff (num * o.den) < (o.num * den) when den > 0

Ensure every operator builds result via Frac ctor so reduce() runs. Do NOT defer reduce.
</action>
  <verify>Frac(1,2)+Frac(1,3)==Frac(5,6); Frac(1,2)*Frac(2,3)==Frac(1,3); Frac(1,2)/Frac(0,1) throws; Frac(-1,2) < Frac(1,2)</verify>
  <done>Add/sub/mul/div and comparisons work; division by zero throws</done>
</task>

<task type="auto">
  <name>Task 3: str() and long-chain growth</name>
  <files>src/frac.h</files>
  <action>
Add std::string str() const. Per RESEARCH: if den==1 return num.str(); else return num.str()+"/"+den.str(). Integers show as "7" not "7/1". Zero: "0". Negatives: "-3/4".

Long-chain invariant: reduce() in every ctor and op keeps denominators bounded. No explicit long-chain test in frac.h — Plan 02-02 will add it to main.cpp.
</action>
  <verify>Frac(3,2).str()=="3/2"; Frac(7).str()=="7"; Frac(0).str()=="0"; Frac(-3,4).str()=="-3/4"</verify>
  <done>str() formats correctly; all Frac ops leave results reduced</done>
</task>

</tasks>

<verification>
- g++ -std=c++20 -O2 -o qseries src/main.cpp compiles (main.cpp will add #include "frac.h" in Plan 02-02; for 02-01, create minimal test or verify frac.h compiles when included)
- Frac(6,4) yields 3/2; Frac(0,5) yields 0/1
- Frac(1,0) and Frac(1,2)/Frac(0,1) throw std::invalid_argument
</verification>

<success_criteria>
- frac.h provides Frac with reduce in every ctor and op
- 6/4→3/2, 0/5→0/1; zero-denom throws
- Ready for Plan 02-02 (test driver)
</success_criteria>

<output>
After completion, create `.planning/phases/02-frac/02-01-SUMMARY.md`
</output>
