---
phase: 45-doc-content
plan: 02
type: execute
wave: 2
depends_on: ["45-01"]
files_modified:
  - website/src/content/docs/manual/bigint-frac.md
  - website/src/content/docs/manual/series-ops.md
  - website/src/content/docs/manual/q-functions.md
  - website/src/content/docs/manual/product-conversion.md
  - website/src/content/docs/manual/relations.md
  - website/src/content/docs/manual/sifting.md
  - website/src/content/docs/manual/repl-commands.md
autonomous: true

must_haves:
  truths:
    - "Every user-facing function (38+) has a typed signature, description, and at least one REPL example"
    - "Manual pages are structured for web reading — not a copy-paste of MANUAL.md"
    - "Function signatures use formal typed syntax: etaq(k: int, T?: int) → Series"
    - "All 7 manual pages have real content (not placeholder text)"
    - "Each manual page is reachable via the sidebar under Reference Manual"
  artifacts:
    - path: "website/src/content/docs/manual/bigint-frac.md"
      provides: "Exact arithmetic foundation overview"
      contains: "BigInt"
    - path: "website/src/content/docs/manual/series-ops.md"
      provides: "series, coeffs, qdegree, lqdegree, subs_q documentation"
      contains: "series"
    - path: "website/src/content/docs/manual/q-functions.md"
      provides: "aqprod, qbin, etaq, theta, theta2-4, tripleprod, quinprod, winquist, T documentation"
      contains: "etaq"
    - path: "website/src/content/docs/manual/product-conversion.md"
      provides: "prodmake, etamake, jacprodmake, qfactor, jac2prod, jac2series documentation"
      contains: "prodmake"
    - path: "website/src/content/docs/manual/relations.md"
      provides: "findhom, findnonhom, findhomcombo, findnonhomcombo, findlincombo, findpoly documentation"
      contains: "findhom"
    - path: "website/src/content/docs/manual/sifting.md"
      provides: "sift, sum/add documentation"
      contains: "sift"
    - path: "website/src/content/docs/manual/repl-commands.md"
      provides: "set_trunc, help, version, legendre, sigma, assignment, scripting, interactive features"
      contains: "set_trunc"
  key_links:
    - from: "all manual pages"
      to: "MANUAL.md source content"
      via: "content rewritten for web (not copy-paste)"
      pattern: "Syntax.*→.*Series"
---

<objective>
Write all 7 reference manual pages, converting the content from MANUAL.md into web-native documentation with formal typed function signatures and REPL examples for every built-in.

Purpose: The reference manual is the primary technical resource for users. Every function must be findable and understandable without reading source code.

Output: 7 complete manual pages covering all 38+ built-in functions plus interactive features.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-doc-content/45-CONTEXT.md
@.planning/phases/45-doc-content/45-RESEARCH.md
@MANUAL.md
@website/astro.config.mjs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write bigint-frac, series-ops, and sifting manual pages</name>
  <files>website/src/content/docs/manual/bigint-frac.md, website/src/content/docs/manual/series-ops.md, website/src/content/docs/manual/sifting.md</files>
  <action>
  Write 3 manual pages. Each replaces the existing placeholder. Use the function entry format from the research doc (### heading, description with KaTeX math, **Syntax** with typed signature, **Parameters**, **Example** with REPL input/output).

  **bigint-frac.md** — title "Exact Arithmetic", description "BigInt and Frac: the foundation of exact computation"

  This is NOT a function reference page. It explains the exact arithmetic foundation:
  1. **Overview** — qseries uses arbitrary-precision integers (BigInt) and exact rational fractions (Frac) for all computation. No floating point anywhere in the math pipeline. This means every coefficient is exact and results are suitable for proving identities, not just checking them numerically.
  2. **BigInt** — Arbitrary-precision integers stored in base $10^9$. Supports all standard arithmetic. Used internally; users rarely interact with BigInt directly.
  3. **Frac** — Exact rational numbers (numerator/denominator pair). Every arithmetic operation auto-reduces via GCD. The fraction $6/4$ is always stored as $3/2$. Zero is always $0/1$.
  4. **Series** — Truncated formal power series with Frac coefficients. Stored as a sparse map from exponent to coefficient. Truncation is always tracked: `f + O(q^T)`. All series operations propagate truncation: `trunc(f*g) = min(trunc(f), trunc(g))`.
  5. **Why exact?** — Brief section on why exact arithmetic matters: floating-point artifacts can produce false identities or miss real ones. Exact computation eliminates this risk entirely.

  Include one REPL example showing exact arithmetic in action:
  ```
  qseries> coeffs(1/etaq(1,20), 0, 10)
  [1, 1, 2, 3, 5, 7, 11, 15, 22, 30, 42]
  ```
  These are exact partition numbers — no rounding, no approximation.

  ---

  **series-ops.md** — title "Series Operations", description "Creating and inspecting power series"

  Document 5 functions, each with the standard format:

  1. `series(f: Series, T?: int) → Series` — Display/re-truncate a series. If T given, truncates to O(q^T). Example: `series(1/etaq(1,50), 10)`.

  2. `coeffs(f: Series, from: int, to: int) → List` — Extract coefficients as a list. Example: `coeffs(1/etaq(1,20), 0, 5)` → `[1, 1, 2, 3, 5, 7]`.

  3. `qdegree(f: Series) → int` — Highest exponent with nonzero coefficient. Example: `qdegree(1+q+q^5)` → `5`.

  4. `lqdegree(f: Series) → int` — Lowest exponent with nonzero coefficient. Example: `lqdegree(q^3+q^5)` → `3`.

  5. `subs_q(f: Series, k: int) → Series` — Substitute $q^k$ for $q$. Replaces every $q^n$ with $q^{kn}$. Example: `subs_q(1+q+q^2, 2)` → `1 + q^2 + q^4 + O(q^50)`.

  Include brief mathematical context where appropriate (e.g., explain what truncation means for formal power series).

  ---

  **sifting.md** — title "Sifting & Summation", description "Extracting subsequences of coefficients and computing finite sums"

  Document 3 functions:

  1. `sift(f: Series, n: int, k: int, T?: int) → Series` — Extract every n-th coefficient starting at residue k. Given $f = \sum a_i q^i$, returns $\sum a_{ni+k} q^i$. This is the key operation for studying partition congruences.

     Include KaTeX math: Given $A(q) = \sum_{n=0}^{\infty} a_n q^n$, `sift(A, m, r)` returns $\sum_{n=0}^{\infty} a_{mn+r} q^n$.

     Example:
     ```
     qseries> p := 1/etaq(1, 200)
     qseries> sift(p, 5, 4, 38)
     ```
     Show that the output relates to Ramanujan's congruence $p(5n+4) \equiv 0 \pmod{5}$.

  2. `sum(expr, var: symbol, lo: int, hi: int) → Series` — Compute $\sum_{\text{var}=\text{lo}}^{\text{hi}} \text{expr}$. The summation variable can appear in the expression.

     Example:
     ```
     qseries> sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8)
     ```
     This computes the Rogers-Ramanujan series.

  3. `add(expr, var: symbol, lo: int, hi: int) → Series` — Alias for `sum`. Identical behavior.

  Mention that `sum`/`add` are the standard way to build q-hypergeometric series.
  </action>
  <verify>Run `cd website && npm run build` — build succeeds. Spot-check that each page has content (not placeholder text) by checking file sizes are >500 bytes.</verify>
  <done>Three manual pages written with proper typed signatures, KaTeX math, and REPL examples. bigint-frac explains the exact arithmetic foundation, series-ops documents 5 functions, sifting documents 3 functions.</done>
</task>

<task type="auto">
  <name>Task 2: Write q-functions and product-conversion manual pages</name>
  <files>website/src/content/docs/manual/q-functions.md, website/src/content/docs/manual/product-conversion.md</files>
  <action>
  Write the two largest manual pages — the core mathematical function references.

  **q-functions.md** — title "q-Series Functions", description "Building q-series: aqprod, etaq, theta functions, and product identities"

  Document 11 functions. Group them logically:

  **Finite q-Products:**

  1. `aqprod(a: Series, q: Series, n: int, T: int) → Series` — Rising q-factorial $(a;q)_n = \prod_{k=0}^{n-1}(1 - aq^k)$.
     Optional form: `aqprod(a, q, n)` uses default truncation.
     Example: `aqprod(q, q, 5, 20)` gives $(q;q)_5$.

  2. `qbin(m: int, n: int, T?: int) → Series` — Gaussian polynomial (q-binomial coefficient) $\binom{n}{m}_q = \frac{(q)_n}{(q)_m(q)_{n-m}}$.
     Optional q-injection form: `qbin(q, m, n, T)`.
     Example: `qbin(3, 5, 20)`.

  3. `T(r: int, n: int, T?: int) → Series` — Andrews' rational function $T_{r,n}$ used in Rogers' proof of Rogers-Ramanujan. Defined by a recursive formula. Memoized internally for performance.
     Example: `T(8, 8)`.

  **Infinite Products (Eta and Theta):**

  4. `etaq(k: int, T?: int) → Series` — Eta product $\prod_{n=1}^{\infty}(1 - q^{kn})$.
     Optional q-injection form: `etaq(q, k, T)`.
     Example: `etaq(1, 20)` — this is Euler's product, whose expansion is the pentagonal number theorem.
     Include KaTeX: $\prod_{n=1}^{\infty}(1-q^n) = \sum_{n=-\infty}^{\infty} (-1)^n q^{n(3n-1)/2}$

  5. `theta(z: Series, T?: int) → Series` — Generalized theta function $\theta(z,q) = \sum_{n=-\infty}^{\infty} z^n q^{n^2}$.
     Optional: `theta(z, q, T)`.

  6. `theta2(T?: int) → Series` — Jacobi theta function $\theta_2(q) = \sum_{n=-\infty}^{\infty} q^{(n+1/2)^2}$.
     Optional: `theta2(q, T)`.

  7. `theta3(T?: int) → Series` — Jacobi theta function $\theta_3(q) = \sum_{n=-\infty}^{\infty} q^{n^2}$.
     Optional: `theta3(q, T)`.

  8. `theta4(T?: int) → Series` — Jacobi theta function $\theta_4(q) = \sum_{n=-\infty}^{\infty} (-1)^n q^{n^2}$.
     Optional: `theta4(q, T)`.

  **Product Identities:**

  9. `tripleprod(z: Series, q: Series, T: int) → Series` — Jacobi triple product identity: $\sum_{n=-\infty}^{\infty} (-1)^n z^n q^{n(n-1)/2} = \prod_{n=1}^{\infty}(1-zq^{n-1})(1-z^{-1}q^n)(1-q^n)$.
     Example: `tripleprod(q, q^3, 10)` gives Euler's pentagonal number theorem.

  10. `quinprod(z: Series, q: Series, T: int) → Series` — Quintuple product identity expansion to $O(q^T)$.
      Example: `quinprod(q, q^5, 20)`.

  11. `winquist(a: Series, b: Series, q: Series, T: int) → Series` — Winquist's identity expansion. Used in proving $p(11n+6) \equiv 0 \pmod{11}$.
      Example: `winquist(q^5, q^3, q^11, 20)`.

  For each function, include: description with KaTeX math for the defining formula, typed syntax line(s), parameters list, and at least one REPL example.

  ---

  **product-conversion.md** — title "Product Conversion", description "Converting series to infinite products: prodmake, etamake, jacprodmake"

  Document 6 functions:

  1. `prodmake(f: Series, T: int) → ProductForm` — Andrews' algorithm: converts a q-series into an infinite product $\prod(1-q^n)^{-a_n}$ that agrees with f to $O(q^T)$.
     Include KaTeX for the algorithm: given $1 + \sum b_n q^n$, compute $c_n = n b_n - \sum_{j=1}^{n-1} b_{n-j} c_j$, then extract $a_n = (c_n - \sum_{d|n, d<n} d \cdot a_d)/n$.
     Example: `prodmake(sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8), 40)` — Rogers-Ramanujan.

  2. `etamake(f: Series, T: int) → EtaProduct` — Identify f as a product of eta functions $\eta(k\tau)$.
     Example: `etamake(theta3(100), 100)` → shows $\theta_3 = \eta(2\tau)^5 / (\eta(\tau)^2 \eta(4\tau)^2)$.

  3. `jacprodmake(f: Series, T: int) → JacProduct` — Identify f as a product of Jacobi-type theta products JAC(a,b,∞).
     Example: `jacprodmake(sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8), 40)` → `JAC(0,5,inf) / JAC(1,5,inf)`.
     Explain the JAC notation: JAC(a,b,∞) = $(q^a;q^b)_\infty (q^{b-a};q^b)_\infty (q^b;q^b)_\infty$.

  4. `qfactor(f: Series, T?: int) → ProductForm` — Factor a finite rational function in q as a q-product. Combines standard factoring with prodmake.
     Example: `qfactor(T(8,8), 20)`.

  5. `jac2prod(var: JacProduct) → string` — Display a Jacobi product in $(q^a;q^b)_\infty$ notation.
     Example: after `rr := jacprodmake(...)`, use `jac2prod(rr)`.

  6. `jac2series(var: JacProduct, T?: int) → Series` — Convert a stored Jacobi product back to a series for further computation.

  Emphasize that prodmake is the central algorithm — it's what makes computational q-series identification possible.
  </action>
  <verify>Run `cd website && npm run build` — build succeeds. Verify q-functions.md covers all 11 functions and product-conversion.md covers all 6 functions. Check that KaTeX math renders (not raw $).</verify>
  <done>q-functions.md documents all 11 q-series construction functions with KaTeX formulas and REPL examples. product-conversion.md documents all 6 conversion functions including prodmake algorithm description.</done>
</task>

<task type="auto">
  <name>Task 3: Write relations and repl-commands manual pages</name>
  <files>website/src/content/docs/manual/relations.md, website/src/content/docs/manual/repl-commands.md</files>
  <action>
  Write the final 2 manual pages.

  **relations.md** — title "Relation Finding", description "Discovering polynomial relations among q-series"

  Introductory paragraph explaining the concept: if q-series are modular forms of a certain weight, they satisfy polynomial relations. These functions convert the problem to linear algebra: expand monomials as q-series, build a matrix, find the kernel.

  Document 6 functions:

  1. `findhom(L: List, n: int, topshift: int) → RelationSet` — Find homogeneous polynomial relations of degree n among q-series in list L.
     Explain: monomials of degree n are generated, their q-expansions computed, and the kernel found via Gaussian elimination over Q.
     Example: `findhom([theta3(100), theta4(100), theta3(subs_q(q,2),100), theta4(subs_q(q,2),100)], 2, 0)` → Gauss AGM relations.

  2. `findnonhom(L: List, n: int, topshift: int) → RelationSet` — Nonhomogeneous polynomial relations (degree ≤ n). Used for modular functions (ratios of modular forms).
     Example: show a theta function ratio relation.

  3. `findhomcombo(f: Series, L: List, n: int, topshift: int, etaopt?: string) → Expression` — Express f as a homogeneous polynomial of degree n in the series from L.
     If `etaopt` is `"yes"`, each monomial is converted to an eta product via etamake.
     Example: Eisenstein series U_{5,6} as polynomial in eta products.

  4. `findnonhomcombo(f: Series, L: List, n_list: List, topshift: int, etaopt?: string) → Expression` — Express f as a nonhomogeneous polynomial in L. The `n_list` parameter specifies degree bounds for each variable.
     Example: Watson's modular equation for powers of 7.

  5. `findlincombo(f: Series, L: List, topshift: int) → Expression` — Express f as a linear combination of series in L. Simpler special case of findhomcombo with degree 1.

  6. `findpoly(x: Series, y: Series, deg1: int, deg2: int, check?: int) → Polynomial` — Find a polynomial $P(X,Y) = 0$ satisfied by q-series x and y, with X-degree ≤ deg1 and Y-degree ≤ deg2.
     Example: `findpoly(x, y, 3, 1)` for cubic modular relations.

  For each function, include the typed signature, description of the algorithm, and at least one REPL example. Explain what topshift does (increase to eliminate spurious relations if needed, usually 0 is fine).

  ---

  **repl-commands.md** — title "REPL & Commands", description "Interactive features, settings, and utility functions"

  This page documents REPL features and utility functions that aren't q-series math.

  Sections:

  1. **Assignment** — `var := expression`. Variables persist in the session. Examples: `rr := sum(...)`, `p := 1/etaq(1)`.

  2. **`set_trunc(N: int)`** — Set default truncation order. Default is 50. Affects `q` and all subsequent computations. Example: `set_trunc(100)`.

  3. **`help` / `help(func)`** — Built-in help system. `help` lists all functions. `help(prodmake)` shows signature and description.

  4. **`version`** — Print package version.

  5. **Number Theory Utilities:**
     - `legendre(a: int, p: int) → int` — Legendre symbol $(a/p)$, returns -1, 0, or 1.
     - `sigma(n: int, k?: int) → int` — Divisor sum $\sigma_k(n) = \sum_{d|n} d^k$. Default k=1.

  6. **Comments** — `# comment` — anything after `#` is ignored.

  7. **Multi-line input** — End a line with `\` to continue on the next line. Continuation prompt is `  > `.

  8. **Output suppression** — End a command with `:` (colon) to suppress output display.

  9. **Script mode** — `qseries < script.qs` runs commands from a file. No banner, output only.

  10. **Tab completion** — Press Tab to autocomplete built-in names and user variables. Unique match auto-completes; multiple matches lists options.

  11. **Command history** — Last 100 commands kept. Up/Down arrows navigate history.

  12. **Timing** — Elapsed time displayed after each command in interactive mode.

  For utility functions (set_trunc, legendre, sigma), use the standard typed signature format with REPL examples. For interactive features, use brief descriptions with usage examples.
  </action>
  <verify>Run `cd website && npm run build` — build succeeds. Verify relations.md documents all 6 relation-finding functions. Verify repl-commands.md covers set_trunc, help, version, legendre, sigma, and all interactive features (tab completion, history, multi-line, etc.).</verify>
  <done>relations.md documents all 6 relation-finding functions with algorithm explanations and examples. repl-commands.md documents all REPL features, utility functions, and interactive capabilities.</done>
</task>

</tasks>

<verification>
1. `cd website && npm run build` completes without errors
2. All 7 manual pages have real content (no placeholder text remains)
3. Every built-in function from MANUAL.md has a corresponding entry with typed signature and REPL example
4. KaTeX math formulas render correctly in function descriptions
5. Pages are structured for web reading with clear headings, not a copy-paste of MANUAL.md
6. Sidebar navigation under "Reference Manual" reaches all 7 pages
</verification>

<success_criteria>
- 38+ built-in functions documented across 7 pages with formal typed signatures
- Every function has at least one REPL input/output example
- Content is rewritten for web (not verbatim from MANUAL.md)
- KaTeX math used for defining formulas (moderate density)
- `npm run build` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/45-doc-content/45-02-SUMMARY.md`
</output>
