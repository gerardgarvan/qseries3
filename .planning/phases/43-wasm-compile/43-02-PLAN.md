---
phase: 43-wasm-compile
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - tests/test_wasm.mjs
  - tests/test_wasm.html
autonomous: false

must_haves:
  truths:
    - "Node.js test script passes all assertions — arithmetic, series, errors, statefulness, banner"
    - "HTML test page loads Wasm and shows test results in the browser"
    - "All REPL-level expressions work via evaluate() — series arithmetic, prodmake, theta, relations"
  artifacts:
    - path: "tests/test_wasm.mjs"
      provides: "Comprehensive Node.js test for Wasm evaluate() API"
      min_lines: 40
    - path: "tests/test_wasm.html"
      provides: "Browser test page for visual Wasm verification"
      min_lines: 30
  key_links:
    - from: "tests/test_wasm.mjs"
      to: "build/wasm/qseries.js"
      via: "dynamic import of Emscripten module"
      pattern: "import.*qseries"
    - from: "tests/test_wasm.html"
      to: "build/wasm/qseries.js"
      via: "script import of Emscripten module"
      pattern: "createQSeries"
---

<objective>
Create comprehensive Node.js and browser tests that verify the full evaluate() API: basic arithmetic, series operations, prodmake, theta functions, error handling, statefulness, and banner.

Purpose: Per user's locked decision, both a Node.js test AND an HTML test page are required. This validates that all REPL-level expressions work through the Wasm API.
Output: tests/test_wasm.mjs, tests/test_wasm.html
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-wasm-compile/43-CONTEXT.md
@.planning/phases/43-wasm-compile/43-RESEARCH.md
@.planning/phases/43-wasm-compile/43-01-SUMMARY.md
@src/main_wasm.cpp
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Node.js test script and HTML test page</name>
  <files>tests/test_wasm.mjs, tests/test_wasm.html</files>
  <action>
**Part A: Create tests/test_wasm.mjs**

Create a Node.js ES module test script that imports the Wasm module and runs comprehensive assertions. Use `createQSeries` from `../build/wasm/qseries.js`.

Test categories to cover (each test prints PASS/FAIL):

1. **Banner:** `Module.get_banner()` === "qseries v2.0"

2. **Basic arithmetic:**
   - `evaluate("1+1")` contains "2"
   - `evaluate("3*7")` contains "21"

3. **Series creation:**
   - `evaluate("etaq(1,20)")` does not start with "error:"
   - Result contains "q" (it's a power series)

4. **Error handling (critical — WASM-02):**
   - `evaluate("etaq(0,50)")` starts with "error:" (not abort/trap)
   - `evaluate("1/0")` starts with "error:"
   - `evaluate("xyz_undefined")` starts with "error:"
   - `evaluate("sift(etaq(1,50),0,0,50)")` starts with "error:" (sift n=0 guard)

5. **Statefulness:**
   - `evaluate("x := etaq(1,20)")` — assignment (may return empty or the series)
   - `evaluate("prodmake(x,15)")` — uses x from prior call, does not start with "error:"

6. **Rogers-Ramanujan (core acceptance):**
   - `evaluate("rr := sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8)")` — no error
   - `evaluate("prodmake(rr,40)")` — result contains "(1-q" (product form)

7. **Theta functions:**
   - `evaluate("theta3(20)")` does not start with "error:"

8. **Suppress output (colon):**
   - `evaluate("y := etaq(1,20):")` returns "" (empty — suppressed)

9. **set_trunc:**
   - `evaluate("set_trunc(30)")` — no error
   - `evaluate("etaq(1,30)")` — series works at new truncation (no error, result contains "q")

10. **help():**
    - `evaluate("help(etaq)")` — returns non-empty string, does not start with "error:"

At the end, print a summary: "X/Y tests passed". Exit with code 0 if all pass, 1 otherwise.

Use this pattern for each test:
```javascript
let passed = 0, failed = 0;
function test(name, condition) {
    if (condition) { console.log(`PASS: ${name}`); passed++; }
    else { console.log(`FAIL: ${name}`); failed++; }
}
```

The import pattern for Emscripten modularized output:
```javascript
import { createRequire } from 'module';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const createQSeries = (await import(join(__dirname, '..', 'build', 'wasm', 'qseries.js'))).default;
const Module = await createQSeries();
```

**Part B: Create tests/test_wasm.html**

Create a standalone HTML file that loads the Wasm module and runs visual tests. The page should be self-contained and work when served from `build/wasm/` (copy test_wasm.html there, or reference with relative path).

The HTML file should:
- Have a simple, clean layout with a `<pre id="output">` for results
- Import `../../build/wasm/qseries.js` (or the user can copy it to the wasm dir)
- Actually, for simplicity, have the script reference `./qseries.js` and instruct the user to copy the HTML to `build/wasm/` or serve from there
- Run the same core tests as the Node.js script
- Show "ALL TESTS PASSED" or list failures
- Use `<script type="module">` for ES module import

The HTML should reference `./qseries.js` (same directory). The user will either copy the HTML to `build/wasm/` or serve from there. Add a comment at the top of the HTML explaining this.

Tests to show in HTML:
1. Banner display
2. `1+1` = `2`
3. `etaq(1,20)` — series output
4. Error handling: `etaq(0,50)` shows error prefix
5. Stateful: assign x, then use x in prodmake
6. Rogers-Ramanujan: sum + prodmake
  </action>
  <verify>
1. `node tests/test_wasm.mjs` — all tests pass, exit code 0
2. `tests/test_wasm.html` exists with proper HTML structure
3. Copy HTML to build/wasm/ and serve: `cd build/wasm && python3 -m http.server 8080` then visit http://localhost:8080/test_wasm.html — shows test results
  </verify>
  <done>
- Node.js test (`node tests/test_wasm.mjs`) passes all assertions with exit code 0
- HTML test page exists and shows test results when served from build/wasm/
- Tests cover: arithmetic, series, error handling, statefulness, Rogers-Ramanujan, theta, help
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify Wasm build and tests end-to-end</name>
  <what-built>Complete Wasm compilation pipeline: repl.h guards, main_wasm.cpp entry point, Makefile wasm target, Node.js test, HTML test page</what-built>
  <how-to-verify>
1. Ensure emsdk is activated: `source /path/to/emsdk/emsdk_env.sh`
2. Build: `make wasm`
3. Run Node.js test: `node tests/test_wasm.mjs`
   - Expected: all tests PASS, "X/X tests passed"
4. Check Wasm size: `gzip -c build/wasm/qseries.wasm | wc -c` — must be under 1,572,864 (1.5 MB)
5. (Optional) Browser test:
   - `cp tests/test_wasm.html build/wasm/`
   - `cd build/wasm && python3 -m http.server 8080`
   - Visit http://localhost:8080/test_wasm.html
   - Expected: all tests show results, "ALL TESTS PASSED"
6. Native build still works: `make clean && make && echo "1+1" | ./dist/qseries.exe`
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
1. `node tests/test_wasm.mjs` exits with code 0, all tests pass
2. `tests/test_wasm.html` loads and shows results in browser
3. Rogers-Ramanujan works through Wasm: evaluate("sum(...)") then evaluate("prodmake(...)") returns product form
4. Error cases return "error: ..." strings, not Wasm traps
5. Native CLI build unaffected
</verification>

<success_criteria>
- Node.js test passes all assertions (arithmetic, series, errors, statefulness, Rogers-Ramanujan, theta, help)
- HTML test page exists and shows successful results when served
- All REPL-level expressions work via evaluate()
- User has verified the full pipeline end-to-end
</success_criteria>

<output>
After completion, create `.planning/phases/43-wasm-compile/43-02-SUMMARY.md`
</output>
