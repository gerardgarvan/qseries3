---
phase: 43-wasm-compile
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/repl.h
  - src/main_wasm.cpp
  - Makefile
autonomous: true

must_haves:
  truths:
    - "emcc compiles src/main_wasm.cpp to build/wasm/qseries.js + qseries.wasm without errors"
    - "evaluate('1+1') returns '2' when loaded in Node.js"
    - "evaluate('etaq(0,50)') returns a string starting with 'error:' — no abort or trap"
    - "Variables persist between evaluate() calls (stateful session)"
    - "Native CLI build still compiles and works after repl.h changes"
  artifacts:
    - path: "src/main_wasm.cpp"
      provides: "Wasm entry point with Embind bindings for evaluate() and get_banner()"
      min_lines: 40
    - path: "src/repl.h"
      provides: "Guarded terminal I/O so it compiles under Emscripten"
      contains: "#ifndef __EMSCRIPTEN__"
    - path: "Makefile"
      provides: "wasm build target"
      contains: "wasm:"
  key_links:
    - from: "src/main_wasm.cpp"
      to: "src/repl.h"
      via: "#include repl.h — uses Environment, evalStmt, display, parse, trim"
      pattern: '#include "repl.h"'
    - from: "src/main_wasm.cpp"
      to: "build/wasm/qseries.js"
      via: "emcc compilation"
      pattern: "EMSCRIPTEN_BINDINGS"
    - from: "Makefile"
      to: "src/main_wasm.cpp"
      via: "wasm target compiles main_wasm.cpp"
      pattern: "main_wasm.cpp"
---

<objective>
Guard terminal I/O in repl.h for Emscripten compatibility, create the Wasm entry point with Embind evaluate()/get_banner() API, and add a Makefile wasm target.

Purpose: This is the foundational Wasm compilation task. After this plan, `make wasm` produces a working .wasm binary that JavaScript can call.
Output: src/main_wasm.cpp, modified src/repl.h, modified Makefile, build/wasm/ artifacts
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-wasm-compile/43-CONTEXT.md
@.planning/phases/43-wasm-compile/43-RESEARCH.md
@src/repl.h
@src/main.cpp
@Makefile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Guard terminal I/O in repl.h and create main_wasm.cpp entry point</name>
  <files>src/repl.h, src/main_wasm.cpp</files>
  <action>
**Part A: Guard terminal I/O in repl.h**

Add `#ifndef __EMSCRIPTEN__` guards around three blocks of terminal-specific code in `repl.h`:

1. **Lines 19-25** — isatty includes/macros. Wrap the `#ifdef _WIN32` / `#include <io.h>` / `isatty` block:
```cpp
#ifndef __EMSCRIPTEN__
#ifdef _WIN32
#include <io.h>
#define stdin_is_tty() _isatty(_fileno(stdin))
#else
#include <unistd.h>
#define stdin_is_tty() isatty(STDIN_FILENO)
#endif
#else
#define stdin_is_tty() false
#endif
```
The `#else` clause defines `stdin_is_tty()` as `false` for Emscripten so any remaining references compile without error.

2. **Lines 38-99** — termios/windows.h includes, RawModeGuard struct, readOneChar function. Wrap the entire block:
```cpp
#ifndef __EMSCRIPTEN__
#if defined(__CYGWIN__) || !defined(_WIN32)
#include <termios.h>
// ... existing RawModeGuard (POSIX) + readOneChar ...
#else
// ... existing RawModeGuard (Windows) + readOneChar ...
#endif
#endif // __EMSCRIPTEN__
```

3. **Lines 1013-end** — The `trim()`, `redrawLineRaw()`, `handleTabCompletion()`, `readLineRaw()`, and `runRepl()` functions. Guard `readLineRaw` and `runRepl` (and their helper `redrawLineRaw`, `handleTabCompletion`):
   - `trim()` must remain UNGUARDED (used by main_wasm.cpp)
   - `display()` must remain UNGUARDED (used by main_wasm.cpp)
   - `evalStmt()` must remain UNGUARDED (used by main_wasm.cpp)
   - Everything from `inline void redrawLineRaw(...)` through `inline void runRepl()` (the end of the file before `#endif`) must be wrapped in `#ifndef __EMSCRIPTEN__` ... `#endif`

Look at repl.h to find the exact line where `redrawLineRaw` starts (around line 1019 after `trim`). Everything from there through the `runRepl` function's closing brace should be guarded. The `display()` function (around line 1134) and `evalStmt()` (around line 1171) are between the helper functions and runRepl — these must NOT be guarded. So the guard structure is:

```cpp
// trim() — NOT guarded
inline std::string trim(...) { ... }

#ifndef __EMSCRIPTEN__
// redrawLineRaw, handleTabCompletion, readLineRaw — guarded
inline void redrawLineRaw(...) { ... }
inline void handleTabCompletion(...) { ... }
inline std::optional<std::string> readLineRaw(...) { ... }
#endif // __EMSCRIPTEN__

// display() — NOT guarded
inline void display(...) { ... }

// evalStmt() — NOT guarded
inline EvalResult evalStmt(...) { ... }

#ifndef __EMSCRIPTEN__
// runRepl() — guarded
inline void runRepl() { ... }
#endif // __EMSCRIPTEN__
```

Check the actual line layout carefully: `display` is at ~1134, `evalStmt` at ~1171, `runRepl` at ~1193. The terminal helpers (`redrawLineRaw`, `handleTabCompletion`, `readLineRaw`) are between `trim` (~1013-1018) and `display` (~1134). Guard the terminal helpers block and the runRepl block separately, leaving display and evalStmt unguarded.

**Part B: Create src/main_wasm.cpp**

Create a new file `src/main_wasm.cpp` with the following implementation:

```cpp
#ifdef __EMSCRIPTEN__
#include <emscripten/bind.h>
#include <sstream>
#include <iostream>
#include "repl.h"

static Environment g_env;
static bool g_initialized = false;

inline std::string evaluate(std::string input) {
    if (!g_initialized) {
        g_env.T = 50;
        g_env.env["q"] = Series::q(50);
        g_initialized = true;
    }

    std::ostringstream oss;
    auto* old_cout = std::cout.rdbuf(oss.rdbuf());
    auto* old_cerr = std::cerr.rdbuf(oss.rdbuf());

    try {
        std::string trimmed = trim(input);
        if (trimmed.empty()) {
            std::cout.rdbuf(old_cout);
            std::cerr.rdbuf(old_cerr);
            return "";
        }

        bool suppress = false;
        if (trimmed.back() == ':') {
            trimmed.pop_back();
            trimmed = trim(trimmed);
            suppress = true;
        }

        StmtPtr stmt = parse(trimmed);
        EvalResult res = evalStmt(stmt.get(), g_env);

        if (!suppress && !std::holds_alternative<std::monostate>(res)
                      && !std::holds_alternative<DisplayOnly>(res)) {
            display(res, g_env, g_env.T);
        }
    } catch (const std::exception& e) {
        oss << "error: " << e.what() << std::endl;
    } catch (...) {
        oss << "error: unknown exception" << std::endl;
    }

    std::cout.rdbuf(old_cout);
    std::cerr.rdbuf(old_cerr);

    std::string result = oss.str();
    while (!result.empty() && result.back() == '\n')
        result.pop_back();
    return result;
}

inline std::string get_banner() {
    return "qseries v2.0";
}

EMSCRIPTEN_BINDINGS(qseries) {
    emscripten::function("evaluate", &evaluate);
    emscripten::function("get_banner", &get_banner);
}
#endif
```

Key design decisions per locked user decisions:
- Return format: plain string, same text CLI would print (streambuf redirect captures all std::cout output)
- Error format: "error: " prefix on all caught exceptions
- Banner: "qseries v2.0" via get_banner()
- Truncation default: T=50 for Wasm session
- Stateful: global Environment persists between calls (Claude's discretion, recommended by research)
- Single statement per evaluate() call (Claude's discretion)
- Suppress output via trailing colon works (matches CLI behavior)
- catch(...) block prevents unknown exceptions from becoming Wasm traps

The g_initialized flag is needed because Environment's constructor already sets T=50, but we want to be explicit about the Wasm default. If the constructor already sets T=50 (which it does: `int T = 50`), the flag is still useful for any future initialization logic.
  </action>
  <verify>
1. Native build still works: `make clean && make` — must compile without errors
2. Verify repl.h guard placement: `grep -n "__EMSCRIPTEN__" src/repl.h` should show 3-4 guard locations
3. Verify main_wasm.cpp exists and includes repl.h: `head -10 src/main_wasm.cpp`
4. Verify guarded functions: `grep -c "readLineRaw\|runRepl\|RawModeGuard\|readOneChar" src/repl.h` still shows all functions present
  </verify>
  <done>
- src/repl.h compiles for both native (g++) and Emscripten (em++) targets
- src/main_wasm.cpp exists with evaluate() and get_banner() Embind bindings
- Native `make` still produces working dist/qseries.exe
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Makefile wasm target and verify Wasm compilation</name>
  <files>Makefile</files>
  <action>
Add a `wasm` target to the existing Makefile. Place it after the existing `dist/qseries.exe` target. Add `build/wasm` directory creation.

Add these lines to the Makefile:

```makefile
# Wasm build (requires emsdk activated: source emsdk_env.sh)
EMXX ?= em++
WASM_FLAGS = -std=c++20 -Oz -lembind \
    -s MODULARIZE=1 \
    -s EXPORT_NAME=createQSeries \
    -s FILESYSTEM=0 \
    -s ALLOW_MEMORY_GROWTH=1 \
    -s ENVIRONMENT=web,worker,node \
    -fwasm-exceptions

wasm: build/wasm/qseries.js

build/wasm:
	mkdir -p build/wasm

build/wasm/qseries.js: src/main_wasm.cpp src/repl.h src/parser.h src/series.h src/frac.h src/bigint.h src/qfuncs.h src/convert.h src/linalg.h src/relations.h | build/wasm
	$(EMXX) $(WASM_FLAGS) -o build/wasm/qseries.js src/main_wasm.cpp
```

Also add `wasm` to the `.PHONY` list, and add `build/wasm/` to `clean`:

In the `.PHONY` line, append `wasm`.

In `clean`, add `rm -rf build/`.

**Important:** The dependency list for `build/wasm/qseries.js` includes ALL header files since they're all transitively included via repl.h. This ensures `make wasm` rebuilds when any source changes.

After adding the target, test the Wasm build by running `make wasm`. This requires the user to have emsdk activated. If em++ is not found, the error message will be clear.

Verify the output:
1. `build/wasm/qseries.js` and `build/wasm/qseries.wasm` exist
2. Check compressed size: `gzip -c build/wasm/qseries.wasm | wc -c` — must be under 1,572,864 bytes (1.5 MB)
3. Quick Node.js smoke test: `node --experimental-vm-modules -e "const m = await import('./build/wasm/qseries.js'); const M = await m.default(); console.log(M.evaluate('1+1'));"` — should print "2"
  </action>
  <verify>
1. `make wasm` completes without errors (requires emsdk activated)
2. `ls build/wasm/qseries.js build/wasm/qseries.wasm` — both files exist
3. Compressed .wasm < 1.5 MB: `gzip -c build/wasm/qseries.wasm | wc -c`
4. Quick smoke test in Node.js: evaluate("1+1") returns "2"
5. `make clean` removes build/ directory
6. `make` (native) still works after Makefile changes
  </verify>
  <done>
- `make wasm` produces build/wasm/qseries.js and build/wasm/qseries.wasm
- Compressed .wasm is under 1.5 MB
- evaluate("1+1") returns "2" in a quick Node.js test
- Native build unaffected
  </done>
</task>

</tasks>

<verification>
1. Native build: `make clean && make` compiles cleanly, `./dist/qseries.exe --version` prints version
2. Wasm build: `make wasm` compiles without errors
3. Wasm size: `gzip -c build/wasm/qseries.wasm | wc -c` < 1,572,864
4. Basic API: Node.js `evaluate("1+1")` returns `"2"`
5. Error handling: Node.js `evaluate("etaq(0,50)")` returns string starting with `"error:"`
6. Statefulness: `evaluate("x := 42")` then `evaluate("x")` returns `"42"`
</verification>

<success_criteria>
- src/repl.h compiles under both g++ (native) and em++ (Emscripten) without errors
- src/main_wasm.cpp exists with evaluate()/get_banner() Embind bindings
- Makefile has a working `wasm` target producing build/wasm/qseries.{js,wasm}
- Compressed .wasm file is under 1.5 MB
- evaluate("1+1") returns "2" in Node.js
- evaluate("etaq(0,50)") returns "error: ..." not a Wasm trap
</success_criteria>

<output>
After completion, create `.planning/phases/43-wasm-compile/43-01-SUMMARY.md`
</output>
