---
phase: 32-etaq-memoization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/qfuncs.h, src/repl.h]
autonomous: true

must_haves:
  truths:
    - "Second call to etaq(k,T) with same arguments returns instantly (no recomputation)"
    - "etaq with non-standard q (e.g. q^2) bypasses cache and computes fresh"
    - "Cache is keyed on (k, T) — different T values produce correct distinct results"
    - "All existing acceptance tests pass unchanged"
    - "set_trunc clears the etaq cache to free memory from old-T entries"
  artifacts:
    - path: "src/qfuncs.h"
      provides: "etaq_cache() accessor, clear_etaq_cache(), cached etaq function"
      contains: "etaq_cache"
    - path: "src/repl.h"
      provides: "clear_etaq_cache wired to set_trunc, help table entry for clear_cache"
      contains: "clear_etaq_cache"
  key_links:
    - from: "src/qfuncs.h"
      to: "etaq_cache()"
      via: "etaq function checks/stores in cache via accessor"
      pattern: "etaq_cache\\(\\)"
    - from: "src/repl.h"
      to: "clear_etaq_cache()"
      via: "set_trunc handler calls clear after changing T"
      pattern: "clear_etaq_cache"
---

<objective>
Add memoization to `etaq(q, k, T)` so repeated calls with the same `(k, T)` on standard q return cached results without recomputation.

Purpose: etaq is the most heavily-called primitive — theta functions, tripleprod, quinprod, winquist, etamake all call it. Caching eliminates redundant O(T/k) Series multiplications.
Output: Modified `src/qfuncs.h` with cache, modified `src/repl.h` with cache-clearing on set_trunc.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-etaq-memoization/32-RESEARCH.md
@src/qfuncs.h
@src/repl.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add etaq memoization cache in qfuncs.h</name>
  <files>src/qfuncs.h</files>
  <action>
Add two new functions before the existing `etaq` function in `src/qfuncs.h`:

1. `etaq_cache()` — accessor returning `static std::map<std::pair<int,int>, Series>&`:
```cpp
inline std::map<std::pair<int,int>, Series>& etaq_cache() {
    static std::map<std::pair<int,int>, Series> cache;
    return cache;
}
```

2. `clear_etaq_cache()` — clears the cache:
```cpp
inline void clear_etaq_cache() {
    etaq_cache().clear();
}
```

3. Modify the existing `etaq(const Series& q, int k, int T)` function:
   - At the top, add standard-q detection: check `q.c.size() == 1 && q.c.begin()->first == 1 && q.c.begin()->second == Frac(1)`
   - If standard q, look up `{k, T}` in `etaq_cache()`. On hit, return the cached value (by value — copy).
   - After the existing computation loop, if standard q, store result in `etaq_cache()[{k, T}]` before returning.
   - Return type remains `Series` (by value). Do NOT return by reference — that would allow cache corruption.

The standard-q check is O(1) and ensures non-standard q arguments (from 3-arg REPL form `etaq(q^2, k, T)`) bypass the cache entirely.

Include `<utility>` if not already included (for `std::pair`). The project already uses `<map>`.
  </action>
  <verify>
Build: `g++ -std=c++20 -O2 -o src/qseries src/main.cpp` (or via Makefile). Must compile without errors or warnings.

Run the main acceptance test:
```bash
bash tests/acceptance.sh
```
All 9 SPEC tests must pass. This proves the cache doesn't change any computed results.
  </verify>
  <done>
etaq function checks/populates a static cache for standard-q calls. Non-standard q bypasses cache. Project compiles and all acceptance tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire cache clearing to REPL set_trunc and run full test suite</name>
  <files>src/repl.h</files>
  <action>
1. In `src/repl.h`, in the `set_trunc` handler (around line 439-448), add a call to `clear_etaq_cache()` after updating `env.T` and `env.env["q"]`. This frees memory from entries computed at old truncation values. The cache is still correct without this (keyed by T), but it prevents unbounded memory growth in long sessions.

2. Optionally add `clear_cache` to the help table (in `getHelpTable()`) and as a REPL command in `dispatchBuiltin`:
   - Help entry: `{"clear_cache", {"clear_cache()", "clear memoization caches (etaq)"}}`
   - Dispatch: if `name == "clear_cache"`, call `clear_etaq_cache()` and return `std::monostate{}`
   - This lets users explicitly free cache memory.

3. Rebuild and run ALL acceptance tests to verify no regressions:
   - `tests/acceptance.sh` (9 SPEC tests)
   - `tests/acceptance-mprodmake.sh`
   - `tests/acceptance-checkprod-checkmult.sh`
   - `tests/acceptance-findmaxind.sh`
   - `tests/acceptance-optional-args.sh`
   - `tests/acceptance-suppress-output.sh`
   - `tests/acceptance-wins.sh`
   - `tests/qol-acceptance.sh`
  </action>
  <verify>
Full rebuild and run all acceptance test scripts. All must pass:
```bash
make clean && make
bash tests/acceptance.sh
bash tests/acceptance-wins.sh
bash tests/qol-acceptance.sh
bash tests/acceptance-mprodmake.sh
bash tests/acceptance-checkprod-checkmult.sh
bash tests/acceptance-findmaxind.sh
bash tests/acceptance-optional-args.sh
bash tests/acceptance-suppress-output.sh
```

Verify cache hit works: run `echo -e "etaq(1,50);\netaq(1,50)" | ./qseries` — both calls should produce identical output (second is cached).
  </verify>
  <done>
set_trunc clears etaq cache. clear_cache REPL command is available. All acceptance tests pass with no regressions. Cache hit returns correct results.
  </done>
</task>

</tasks>

<verification>
1. All existing acceptance tests pass (PERF-03 requirement — no regressions)
2. `etaq(1,50)` called twice produces identical output; second call uses cache
3. `etaq(q^2, 1, 50)` computes fresh (not from cache for etaq(q,1,50))
4. `set_trunc(100)` clears the cache (subsequent etaq calls recompute)
5. `clear_cache()` REPL command clears the cache
6. Project compiles with `g++ -std=c++20 -O2 -static`
</verification>

<success_criteria>
- PERF-01 satisfied: etaq(k,T) results are memoized — repeated calls with same (k,T) return cached Series
- PERF-03 satisfied: all existing acceptance tests pass after optimization
- Cache is transparent: identical behavior for all inputs, just faster on repeated calls
</success_criteria>

<output>
After completion, create `.planning/phases/32-etaq-memoization/32-01-SUMMARY.md`
</output>
