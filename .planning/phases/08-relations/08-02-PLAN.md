---
phase: 08-relations
plan: 02
type: execute
wave: 2
depends_on:
  - "08-01"
files_modified:
  - src/linalg.h
  - src/relations.h
  - src/main.cpp
autonomous: true

must_haves:
  truths:
    - "solve(M, b) returns optional solution x to M*x = b"
    - "findhomcombo(f, L, n, topshift, etaoption) expresses f as homogeneous polynomial in L"
    - "findnonhomcombo(f, L, n_list, topshift, etaoption) expresses f as polynomial in L with per-variable degree bounds"
    - "findnonhomcombo yields Watson's modular equation T² = (49ξ³+35ξ²+7ξ)T + ... (TEST-08)"
  artifacts:
    - path: src/linalg.h
      provides: solve(M, b)
      contains: std::optional&lt;std::vector&lt;Frac&gt;&gt; solve(...)
    - path: src/relations.h
      provides: findhomcombo, findnonhomcombo
      contains: findhomcombo, findnonhomcombo
    - path: src/main.cpp
      provides: TEST-08 (Watson)
  key_links:
    - from: src/relations.h
      to: src/linalg.h
      via: solve(M^T, f_coeffs)
      pattern: "solve"
    - from: findnonhomcombo
      to: TEST-08
      via: findnonhomcombo(T², [T, xi], [1, 7], 0)
      pattern: "findnonhomcombo"
---

<objective>
Add solve(M, b) to linalg; implement findhomcombo and findnonhomcombo. Combo functions solve M^T·c = f to express f as polynomial in L. Success: TEST-08 (Watson's modular equation).

Purpose: Complete relation-finding API; Watson identity via findnonhomcombo.
Output: linalg.h solve; relations.h findhomcombo, findnonhomcombo; main.cpp TEST-08.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-relations/08-CONTEXT.md
@.planning/phases/08-relations/08-RESEARCH.md
@.planning/phases/08-relations/08-01-SUMMARY.md
@src/linalg.h
@src/relations.h
@src/convert.h
@src/qfuncs.h
@SPEC.md (Layer 7)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add solve(M, b) to linalg.h</name>
  <files>src/linalg.h</files>
  <action>
Add solve capability to linalg.h:

1. **Signature:** `std::optional&lt;std::vector&lt;Frac&gt;&gt; solve(const std::vector&lt;std::vector&lt;Frac&gt;&gt;&amp; M, const std::vector&lt;Frac&gt;&amp; b);`

2. **Solves M·x = b.** M is rows×cols; b has length rows. Returns solution x (length cols) if consistent; std::nullopt if inconsistent.

3. **Algorithm:** Build augmented matrix [M | b]. Call gauss_to_rref on a copy. Check consistency: if any row has pivot in the last column (all zeros in M part, nonzero in b part), return nullopt. Otherwise back-substitute: free variables = 0; solve for pivot variables from RREF. Return one particular solution.

4. **Expose gauss_to_rref:** Currently in anonymous namespace. solve needs it — either keep anonymous and call from solve (same TU), or move to a shared helper. Same file is fine.

5. **Implementation detail:** Augment A = [M | b], RREF. Pivot cols exclude last col. If last col has pivot (i.e. no pivot in last col, but we detect inconsistent row: zeros in cols 0..ncols-1 and nonzero in last) → nullopt. Back-sub: for each pivot col, x[pc] = A[pi][last] - sum over free cols of A[pi][fc]*x[fc]; with free=0, x[pc]=A[pi][last].
</action>
  <verify>Add minimal test: solve([[1,0],[0,1]], [1,2]) → [1,2]; solve([[1,1],[2,2]], [1,2]) → nullopt (inconsistent).</verify>
  <done>solve(M,b) exists; returns solution when consistent, nullopt when inconsistent.</done>
</task>

<task type="auto">
  <name>Task 2: Implement findhomcombo and findnonhomcombo; TEST-08</name>
  <files>src/relations.h, src/main.cpp</files>
  <action>
Implement combo functions in relations.h and add TEST-08:

1. **findhomcombo(f, L, n, topshift, etaoption):** Monomials = homogeneous degree n (same as findhom). Build matrix M rows=monomials, cols=q-powers. f_coeffs = f.coeffList(0, num_cols-1). Solve M^T·c = f_coeffs. Return std::optional&lt;std::vector&lt;Frac&gt;&gt; — solution c or nullopt. etaoption: if true, for display only, try etamake on each monomial; best-effort, fallback to "X_i^a" on failure. For Phase 8, etaoption can be stubbed (show raw coeffs) if display is deferred to REPL.

2. **findnonhomcombo(f, L, n_list, topshift, etaoption):** n_list = [n₁,...,nₖ] = max degree per variable. Monomials: L[0]^d0 * ... * L[k-1]^d{k-1} for 0≤d_i≤n_list[i]. Count: (n_list[0]+1)*...*(n_list[k-1]+1). Build M, solve M^T·c = f_coeffs. Return optional solution.

3. **TEST-08 (main.cpp):**
   - xi := q² * etaq(q,49,100) / etaq(q,1,100)
   - T := q * (etaq(q,7,100) / etaq(q,1,100))^4
   - findnonhomcombo(T*T, [T, xi], {1, 7}, 0, false)
   - Expected: T² = (49ξ³+35ξ²+7ξ)T + 343ξ⁷+343ξ⁶+147ξ⁵+49ξ⁴+21ξ³+7ξ²+ξ
   - Verify: solution coeffs match (1,0) → 0, (0,7) → 343, (0,6) → 343, (0,5) → 147, (0,4) → 49, (0,3) → 21, (0,2) → 7, (0,1) → 1, (1,3) → 49, (1,2) → 35, (1,1) → 7. Variable order X1=T, X2=ξ. Monomial order: (0,0),(1,0),(0,1),(1,1),...,(1,7) — row-major by exponent vector.

4. **Truncation:** T = min(f.trunc, all L[i].trunc). Ensure series have sufficient truncation (100 for TEST-08).
</action>
  <verify>Build and run; TEST-08 passes — findnonhomcombo returns solution matching Watson's modular equation coeffs.</verify>
  <done>findhomcombo and findnonhomcombo implemented; TEST-08 passes.</done>
</task>

</tasks>

<verification>
- solve(M,b) works for consistent systems; returns nullopt for inconsistent.
- findhomcombo and findnonhomcombo return optional solution vectors.
- TEST-08: findnonhomcombo(T², [T, xi], [1,7], 0) yields Watson equation coeffs.
</verification>

<success_criteria>
- solve(M,b) added to linalg; reuse RREF logic.
- findhomcombo and findnonhomcombo solve M^T·c = f per RESEARCH.
- TEST-08 (Watson) passes.
- All five relation functions (findhom, findnonhom, findhomcombo, findnonhomcombo, findpoly) implemented.
</success_criteria>

<output>
After completion, create `.planning/phases/08-relations/08-02-SUMMARY.md`
</output>
