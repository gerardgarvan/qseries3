---
phase: 08-relations
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/relations.h
  - src/main.cpp
autonomous: true

must_haves:
  truths:
    - "findhom(L, n, topshift) returns homogeneous relations of degree n among L"
    - "findhom on theta3, theta4, theta3(q²), theta4(q²) yields X₁²+X₂²-2X₃², -X₁X₂+X₄² (TEST-05)"
    - "findnonhom(L, n, topshift) returns nonhomogeneous relations degree ≤ n (includes constant 1)"
    - "findpoly(x, y, deg1, deg2, check?) returns polynomial relations P(X,Y)=0 between two series"
  artifacts:
    - path: src/relations.h
      provides: findhom, findnonhom, findpoly; monomial generation; matrix build; kernel(M^T)
      contains: findhom, findnonhom, findpoly, formatRelation or equivalent
    - path: src/main.cpp
      provides: TEST-05 (Gauss AGM), tests for findnonhom, findpoly
  key_links:
    - from: src/relations.h
      to: src/linalg.h
      via: kernel(transpose(M))
      pattern: "kernel"
    - from: src/relations.h
      to: src/series.h
      via: coeff, coeffList, truncTo, *, pow
      pattern: "Series|coeff|coeffList"
    - from: src/main.cpp
      to: TEST-05
      via: findhom([theta3, theta4, theta3(q²), theta4(q²)], 2, 0)
      pattern: "findhom"
---

<objective>
Implement kernel-based relation finders: findhom, findnonhom, findpoly. Build matrix rows=monomial q-expansions, cols=q-powers; kernel of M^T yields relations. Success: TEST-05 (Gauss AGM).

Purpose: Polynomial relation discovery via linear algebra over Q.
Output: src/relations.h with findhom, findnonhom, findpoly; main.cpp TEST-05 and relation tests.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-relations/08-CONTEXT.md
@.planning/phases/08-relations/08-RESEARCH.md
@src/linalg.h
@src/series.h
@src/qfuncs.h
@SPEC.md (Layer 7)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create relations.h with findhom and TEST-05</name>
  <files>src/relations.h, src/main.cpp</files>
  <action>
Create src/relations.h (header-only, inline) and implement findhom:

1. **Includes:** series.h, linalg.h, frac.h, vector, optional, string.

2. **Monomial generation (homogeneous degree n):** Generate all exponent vectors (a₁,...,aₖ) with a_i ≥ 0 and Σ a_i = n (stars-and-bars). For each, compute monomial = L[0]^a₀ * L[1]^a₁ * ... truncated to T.

3. **Matrix build:** T = min(series truncations); num_cols = T + topshift. Each row = monomial's q-coefficients [coeff(0), coeff(1), ..., coeff(num_cols-1)]. Use Series::coeffList(0, num_cols-1) or equivalent.

4. **Relation extraction:** Transpose M (rows↔cols) so kernel receives M^T. kernel(M^T) returns basis; each vector c satisfies Σ c_i·monomial_i = 0.

5. **Output:** Return std::vector&lt;std::vector&lt;Frac&gt;&gt; — each inner vector is coefficients for monomials. Add helper formatRelation(coeffs, exponents, varNames) → "X₁²+X₂²-2X₃²" for display (optional; tests can verify coefficients directly).

6. **findhom signature:** `std::vector&lt;std::vector&lt;Frac&gt;&gt; findhom(const std::vector&lt;Series&gt;&amp; L, int n, int topshift);`

7. **main.cpp TEST-05:** Build L = [theta3(q,100), theta4(q,100), theta3(q,100).subs_q(2), theta4(q,100).subs_q(2)], call findhom(L, 2, 0). CHECK that result has 2 relations. Verify first relation coeffs correspond to X₁²+X₂²-2X₃² (i.e. coeff for X₁²=1, X₂²=1, X₃²=-2, others 0) and second to -X₁X₂+X₄². Variable order X1=L[0], X2=L[1], X3=L[2], X4=L[3]. Monomial order for degree 2 with 4 vars: X1², X1X2, X1X3, X1X4, X2², X2X3, X2X4, X3², X3X4, X4² (C(2+4-1,4-1)=10).

PITFALL: Pass M^T to kernel, not M. RESEARCH: rows=monomials, cols=q-powers; kernel(M^T) gives coefficient vectors.
</action>
  <verify>g++ -std=c++20 -O2 -o qseries src/main.cpp 2>&1; run binary; TEST-05 section shows findhom returns 2 relations; coefficients match X₁²+X₂²-2X₃² and -X₁X₂+X₄².</verify>
  <done>findhom implemented; TEST-05 passes; Gauss AGM relations recovered.</done>
</task>

<task type="auto">
  <name>Task 2: Implement findnonhom and findpoly</name>
  <files>src/relations.h, src/main.cpp</files>
  <action>
Extend relations.h with findnonhom and findpoly:

1. **findnonhom(L, n, topshift):** Same as findhom but include ALL monomials of degree 0 through n. Degree 0 = constant 1 (Series::one(T)). Monomial count: Σ_{d=0}^{n} C(d+k-1,k-1). Build matrix, transpose, kernel(M^T). Return std::vector&lt;std::vector&lt;Frac&gt;&gt;.

2. **findpoly(x, y, deg1, deg2, check?):** Two series x, y. Monomials: X^i·Y^j for i=0..deg1, j=0..deg2. Count: (deg1+1)*(deg2+1). Build matrix (rows=monomials, cols=q-powers). T = min(x.trunc, y.trunc); num_cols = T + topshift. kernel(M^T). Optional check: if provided, verify relation to O(q^check). Return std::vector&lt;std::vector&lt;Frac&gt;&gt;.

3. **main.cpp tests:** Add minimal tests: findnonhom on small input (e.g. 2 series, degree 1) returns valid relations; findpoly on two simple series returns at least one relation or empty if none. Use existing CHECK macro.

4. **Monomial order:** findnonhom: list by total degree 0,1,...,n; within each degree use same order as findhom. findpoly: lex order (0,0), (1,0), (0,1), (2,0), (1,1), (0,2), ... or column-major i then j.
</action>
  <verify>Build and run; findnonhom and findpoly compile and return; tests pass.</verify>
  <done>findnonhom and findpoly implemented; basic tests pass.</done>
</task>

</tasks>

<verification>
- Build succeeds with no warnings.
- findhom([theta3, theta4, theta3(q²), theta4(q²)], 2, 0) yields 2 relations: X₁²+X₂²-2X₃², -X₁X₂+X₄².
- findnonhom and findpoly return valid relation vectors.
</verification>

<success_criteria>
- findhom, findnonhom, findpoly implemented per SPEC and 08-RESEARCH.
- TEST-05 (Gauss AGM) passes.
- Matrix orientation: rows=monomials, cols=q-powers; kernel(M^T) used.
</success_criteria>

<output>
After completion, create `.planning/phases/08-relations/08-01-SUMMARY.md`
</output>
