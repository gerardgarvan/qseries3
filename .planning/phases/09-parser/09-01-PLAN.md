---
phase: 09-parser
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/parser.h, main.cpp]
autonomous: true

must_haves:
  truths:
    - "Tokenizer produces correct tokens for identifiers, integers, q, operators, :=, comments"
    - "Parser produces AST for expressions, binary ops, unary -, function calls"
    - "Parser produces AST for assignments (name := expr)"
    - "sum/add(expr, var, lo, hi) and list [a,b,c] parse correctly"
  artifacts:
    - path: src/parser.h
      provides: Token struct, Tokenizer, AST types, Parser
      min_lines: 200
  key_links:
    - from: src/parser.h
      to: "Tokenizer.next()"
      via: token stream
      pattern: "Token.*next|getNextToken"
    - from: src/parser.h
      to: parseExpr
      via: precedence climbing
      pattern: "parseExpr.*minPrec|parsePrimary"
---

<objective>
Implement hand-rolled tokenizer + recursive-descent expression parser in src/parser.h. Produces AST for expressions, assignments, function calls, sum/add, and list literals. No external deps; header-only.

Purpose: Phase 10 REPL needs parsed expressions. Parser is standalone (no Series/Frac deps).
Output: src/parser.h; optional main.cpp tests for parser verification.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-parser/09-RESEARCH.md
@SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Tokenizer</name>
  <files>src/parser.h</files>
  <action>
Implement in src/parser.h:

1. Token struct with Kind enum: IDENT, INT, Q, ASSIGN, PLUS, MINUS, STAR, SLASH, CARET, LPAREN, RPAREN, LBRACK, RBRACK, COMMA, END. Include std::string text for IDENT and INT lexemes.

2. Tokenizer class: holds std::string input, size_t pos. next() returns next Token. Skip whitespace; skip # comments to end of line. When seeing `:`, peek next char; if `=`, consume both and return ASSIGN. For alpha/underscore, scan identifier; if "q" return Q else IDENT. For digits, scan integer and return INT. Single chars: + - * / ^ ( ) [ ] , each maps to token kind. Return END at EOF.

3. Throw std::runtime_error (or ParseError with position) on invalid input (e.g. `:` not followed by `=`). Use inline in header per project style.

Reference: 09-RESEARCH.md token kinds and pitfalls (#5, #6).
  </action>
  <verify>
Add minimal test in main.cpp: tokenize "x := 42 + q # comment" and assert tokens: IDENT "x", ASSIGN, INT "42", PLUS, Q, END. Build with g++ -std=c++20 -O2 -o qseries main.cpp and run.
  </verify>
  <done>Tokenizer produces correct tokens; main.cpp parser test block compiles and tokenizer assertions pass.</done>
</task>

<task type="auto">
  <name>Task 2: AST types and Parser core</name>
  <files>src/parser.h</files>
  <action>
Add to src/parser.h:

1. AST node types (std::variant or tagged struct, no virtuals per .cursorrules):
   - IntLit (int64_t val), Q, Var (std::string name), BinOp (Op, left, right), UnOp (Op, operand), Call (name, vector&lt;Expr&gt; args), List (vector&lt;Expr&gt; elements), Sum (body, var string, lo, hi), Assign (name, rhs).
   Use std::unique_ptr or variant as in RESEARCH.md. Expr = variant/ptr of these; Stmt = Assign | Expr.

2. Parser class: holds Tokenizer (or vector&lt;Token&gt;), pos. peek(), consume(), expect(Kind).

3. parsePrimary(): unary `-` at start → consume, parsePrimary(), return UnOp. INT → IntLit. Q → Q node. IDENT: if LPAREN follows → parse call or sum (defer sum/add to Task 3); else return Var(name). LPAREN → parseExpr(0), expect RPAREN, return inner. LBRACK → parse list (defer to Task 3); for now throw "list not yet" or implement in Task 3.

4. parseExpr(int minPrec): left = parsePrimary(); loop: peek op; if END/RPAREN/COMMA/RBRACK break; prec = precedence(op); if prec &lt; minPrec break; consume; rightAssoc = (op==CARET); nextMin = rightAssoc ? prec : prec+1; right = parseExpr(nextMin); left = BinOp(op, left, right). Return left. Precedence: +- 1, */ 2, ^ 4 (right-assoc). ASSIGN not in parseExpr.

5. parseStmt(): e = parseExpr(0); if e is Var and peek()==ASSIGN: consume ASSIGN, rhs = parseExpr(0), return Assign(name, rhs); else return ExprStmt(e).

6. Top-level parse(std::string) that constructs Tokenizer, runs parseStmt().
  </action>
  <verify>
Test: parse "1 + 2 * 3" → correct BinOp tree; parse "a := etaq(q,1,50)" → Assign; parse "-q" → UnOp; parse "a ^ b ^ c" → right-associated (a^(b^c)). Run via main.cpp.
  </verify>
  <done>AST types exist; parseExpr, parsePrimary, parseStmt produce correct trees for expressions, assignments, unary minus; ^ right-associative.</done>
</task>

<task type="auto">
  <name>Task 3: sum/add, list literals, and parser tests</name>
  <files>src/parser.h, main.cpp</files>
  <action>
Complete parser.h:

1. In parsePrimary, when IDENT + LPAREN and name is "sum" or "add": parse sum call. consume LPAREN; body = parseExpr(0); expect COMMA; id = expect(IDENT); expect COMMA; lo = parseExpr(0); expect COMMA; hi = parseExpr(0); expect RPAREN; return Sum(body, id.text, lo, hi).

2. In parsePrimary, when LBRACK: consume LBRACK; parse comma-separated exprs (parseExpr(0) in loop, comma between); expect RBRACK; return List(elements).

3. parseCommaSeparatedExprs() helper: parseExpr(0), while peek()==COMMA consume COMMA, push parseExpr(0). Use for call args and list elements.

4. Ensure generic function calls (non-sum/add) use parseCommaSeparatedExprs then expect RPAREN.

Add main.cpp parser tests (or extend existing):
- sum(q^n, n, 0, 10) → Sum node with body q^n, var "n", lo 0, hi 10
- add(1, k, 1, 5) → Sum node
- [theta3(q,100), theta4(q,100)] → List of two Call nodes
- "2 + 3 * 4" precedence
- "q^(n^2)" right-assoc
- "# comment\n x := 1" comment stripped
  </action>
  <verify>
g++ -std=c++20 -O2 -o qseries main.cpp. Run main; parser tests pass. Parse sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8) without error (Rogers-Ramanujan pattern).
  </verify>
  <done>sum/add and list literals parse correctly; Rogers-Ramanujan-style sum parses; all parser tests pass.</done>
</task>

</tasks>

<verification>
- g++ -std=c++20 -O2 -o qseries main.cpp compiles
- main runs parser tests: tokenizer (ident, int, q, :=, comment), expressions (precedence, unary -, ^ right-assoc), assignments, sum/add, lists
- Parse "sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8)" succeeds
</verification>

<success_criteria>
1. Tokenizer handles IDENT, INT, Q, ASSIGN, operators, # comments
2. Parser produces AST for expressions, assignments, function calls
3. sum/add(expr, var, lo, hi) and [a,b,c] parse correctly
4. REPL-01 success criteria met
</success_criteria>

<output>
After completion, create .planning/phases/09-parser/09-01-SUMMARY.md
</output>
