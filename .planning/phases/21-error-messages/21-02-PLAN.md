---
phase: 21-error-messages
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/repl.h
autonomous: true

must_haves:
  truths:
    - "Runtime errors from built-ins show function name (e.g. etaq: expected ...)"
    - "Error display includes line number in script mode"
    - "Error format is actionable (user can locate and fix)"
  artifacts:
    - path: src/repl.h
      provides: runtimeErr helper, ev/evi wrap with func prefix, runRepl inputLineNum + format
  key_links:
    - from: dispatchBuiltin ev/evi lambdas
      to: runtimeErr
      via: "catch and rethrow with func prefix"
      pattern: "runtimeErr\\(name"
    - from: runRepl catch block
      to: inputLineNum
      via: "prepend 'line N: ' when script mode"
      pattern: "inputLineNum|line.*col"
---

<objective>
Standardize runtime error messages with function name prefix and improve REPL error display with line number in script mode. Built-in failures show "func: message"; REPL prints "error: [line N:] message".

Purpose: QOL-07 — Runtime errors show function name and context; messages actionable
Output: repl.h with runtimeErr helper and formatted error display
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md (QOL-07)
@.planning/phases/21-error-messages/21-RESEARCH.md
@src/repl.h
</context>

<tasks>

<task type="auto">
  <name>Add runtimeErr helper and standardize built-in error messages</name>
  <files>src/repl.h</files>
  <action>
1. Add helper near top of repl.h (after includes, before EnvValue):
   ```cpp
   inline std::string runtimeErr(const std::string& func, const std::string& msg) {
       return func.empty() ? msg : (func + ": " + msg);
   }
   ```

2. In dispatchBuiltin, wrap ev and evi so exceptions are rethrown with function name:
   - ev: try { return evalAsSeries(...); } catch (const std::exception& e) { throw std::runtime_error(runtimeErr(name, e.what())); }
   - evi: try { return evalToInt(...); } catch (const std::exception& e) { throw std::runtime_error(runtimeErr(name, e.what())); }
   This ensures evalToInt, evalAsSeries, getSeriesFromEnv failures show "etaq: ...", "prodmake: ..." etc.

3. Update direct throws in dispatchBuiltin to use runtimeErr(name, msg) for consistency. Replace throw std::runtime_error("etaq(k,T) or ...") with throw std::runtime_error(runtimeErr(name, "expected etaq(k,T) or etaq(q,k,T), got N arguments")). Apply to all builtins that throw (aqprod, etaq, theta2/3/4, theta, qbin, tripleprod, quinprod, winquist, sift, T, prodmake, etamake, jacprodmake, jac2prod, qfactor, series, coeffs, set_trunc, findhom, findnonhom, findhomcombo, findnonhomcombo, findpoly, legendre, sigma, subs_q, help). For messages that already say "X expects N arguments", use runtimeErr(name, "expects N arguments" + details). Keep messages short and actionable.
</action>
  <verify>Run `etaq(1)` (wrong arity) — error should start with "etaq:". Run `prodmake(x, 50)` with x undefined — error should include "prodmake:" or propagate from lookup. Build and run tests/acceptance.sh.</verify>
  <done>Built-in errors include function name prefix; ev/evi propagate with prefix.</done>
</task>

<task type="auto">
  <name>Add script-mode line number and format error display</name>
  <files>src/repl.h</files>
  <action>
1. In runRepl(), add `size_t inputLineNum = 0` before the main loop. Increment it at the start of each iteration (when we're about to process a command). Increment only for non-empty trimmed input (so blank lines don't count, matching user mental model of "line N = Nth command in script").

2. In the catch block, change from:
   `std::cerr << "error: " << e.what() << std::endl;`
   to:
   `std::cerr << "error: ";`
   `if (!stdin_is_tty() && inputLineNum > 0) std::cerr << "line " << inputLineNum << ": ";`
   `std::cerr << e.what() << std::endl;`
   Only add "line N: " when in script mode (not TTY). Parse errors from 21-01 already include "line L, col C" in e.what(), so the full output will be e.g. "error: line 5: parser: line 1, col 7: expected :=" for script line 5.
</action>
  <verify>Create script: `echo '1+1' > /tmp/t.qs; echo 'foo : 1' >> /tmp/t.qs; echo '2+2' >> /tmp/t.qs`. Run `qseries < /tmp/t.qs`. First line succeeds; second shows "error: line 2: parser: line 1, col 6: expected :="; third not reached if we exit on error, or continue depending on current behavior. Verify line number appears. Interactive mode: `echo "foo : 1" | qseries` should show "error: parser: line 1, col 6: expected :=" (no "line N" prefix when stdin is pipe but not TTY — actually stdin_is_tty() is false when piping, so we'd add line number. That's correct for "script" from pipe too.)</verify>
  <done>Script mode errors show "line N:" prefix; interactive errors unchanged format.</done>
</task>

</tasks>

<verification>
- g++ -std=c++20 -O2 -o qseries main.cpp compiles
- etaq(1) yields "etaq: expected ..." (function name in message)
- Script with parse error on line 2 shows "error: line 2: parser: ..."
- tests/acceptance.sh passes
</verification>

<success_criteria>
- Runtime errors from built-ins show function name
- Script mode error display includes command line number
- All 9 SPEC acceptance tests pass
</success_criteria>

<output>
After completion, create .planning/phases/21-error-messages/21-02-SUMMARY.md
</output>
