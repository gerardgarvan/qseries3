---
phase: 42-garvan-tutorial-coverage
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/convert.h
  - src/repl.h
autonomous: true

must_haves:
  truths:
    - "T(0,30,50) completes in <2s (was intractable without memoization)"
    - "min(3,1,4,1,5) returns 1"
    - "max(3,1,4,1,5) returns 5"
    - "help(min) and help(max) display valid help text"
    - "All existing acceptance tests still pass"
  artifacts:
    - path: "src/convert.h"
      provides: "Memoized T_rn via wrapper+helper pattern"
      contains: "T_rn_impl"
    - path: "src/repl.h"
      provides: "min/max builtin dispatch and help table entries"
      contains: "name == \"min\""
  key_links:
    - from: "src/repl.h"
      to: "src/convert.h"
      via: "T_rn() call signature unchanged"
      pattern: "T_rn\\("
---

<objective>
Add T_rn memoization to eliminate exponential recursive blowup, and add min/max integer builtins.

Purpose: T(0,30,50) is currently intractable due to naive recursion (exponential call tree). Adding a per-call std::map cache reduces it to ~450 unique subproblems. min/max are needed for tutorial §4.2 coverage.
Output: Modified convert.h with memoized T_rn, modified repl.h with min/max dispatch and help entries.
</objective>

<execution_context>
@.planning/phases/42-garvan-tutorial-coverage/42-CONTEXT.md
@.planning/phases/42-garvan-tutorial-coverage/42-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/convert.h
@src/repl.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add T_rn memoization in convert.h</name>
  <files>src/convert.h</files>
  <action>
  Replace the existing T_rn function (lines 236-248) with a wrapper+helper pattern:

  1. Rename the current `T_rn` to `T_rn_impl` and add a `std::map<std::pair<int,int>, Series>& cache` parameter.
  2. At the top of `T_rn_impl` (after base cases n==0 and n==1), check `cache.find({r, n})`. If found, return cached value.
  3. Before returning the computed `sum`, store it in `cache[{r, n}]`.
  4. Create the public `T_rn(int r, int n, int T_trunc)` wrapper that creates a local `std::map<std::pair<int,int>, Series> cache` and calls `T_rn_impl(r, n, T_trunc, cache)`.
  5. The recursive call inside the loop must call `T_rn_impl(r + 2*k, n - 2*k, T_trunc, cache)` (not the wrapper).
  6. The public signature is unchanged so all existing call sites (repl.h dispatch) continue to work without modification.

  Research code example (42-RESEARCH.md Pattern 1) shows the exact implementation. Use `std::make_pair(r, n)` or `{r, n}` for the key.
  </action>
  <verify>
  Build: `g++ -std=c++20 -O2 -o qseries main.cpp` — compiles without errors.
  Test: `echo 'T(0,8,50)' | ./qseries` — produces series output (existing behavior preserved).
  Test: `echo 'T(0,30,50)' | timeout 10 ./qseries` — completes within seconds (was intractable before).
  </verify>
  <done>T_rn(0,30,50) completes in <2s. Existing T(r,n,T) calls produce identical results. No compilation errors.</done>
</task>

<task type="auto">
  <name>Task 2: Add min/max integer builtins in repl.h</name>
  <files>src/repl.h</files>
  <action>
  1. In `getHelpTable()` (around line 195, before the closing `};`), add two entries:
     ```
     {"min", {"min(a, b, ...)", "minimum of 2 or more integers"}},
     {"max", {"max(a, b, ...)", "maximum of 2 or more integers"}},
     ```

  2. In `dispatchBuiltin()`, after the `sigma` / `divisors` / `legendre` / `jacobi` / `kronecker` block (around line 680), add min/max dispatch:
     ```
     if (name == "min") {
         if (args.size() < 2)
             throw std::runtime_error(runtimeErr(name, "expects 2 or more arguments"));
         int64_t result = evi(0);
         for (size_t i = 1; i < args.size(); ++i)
             result = std::min(result, evi(i));
         return result;
     }
     if (name == "max") {
         if (args.size() < 2)
             throw std::runtime_error(runtimeErr(name, "expects 2 or more arguments"));
         int64_t result = evi(0);
         for (size_t i = 1; i < args.size(); ++i)
             result = std::max(result, evi(i));
         return result;
     }
     ```
     These follow the existing `legendre`/`sigma` int64_t dispatch pattern but with variadic args. They return `int64_t` which is already an accepted EnvValue variant type.

  3. `std::min` and `std::max` are in `<algorithm>` which should already be included. If not, add the include.
  </action>
  <verify>
  Build: `g++ -std=c++20 -O2 -o qseries main.cpp` — compiles without errors.
  Test: `echo 'min(3,1,4,1,5)' | ./qseries` — outputs `1`.
  Test: `echo 'max(3,1,4,1,5)' | ./qseries` — outputs `5`.
  Test: `echo 'min(7,2)' | ./qseries` — outputs `2`.
  Test: `echo 'help(min)' | ./qseries` — shows help text.
  Test: `echo 'help(max)' | ./qseries` — shows help text.
  </verify>
  <done>min and max builtins accept 2+ integer arguments, return correct results, appear in help table. Compilation clean.</done>
</task>

</tasks>

<verification>
1. Build succeeds: `g++ -std=c++20 -O2 -o qseries main.cpp`
2. T(0,30,50) completes in <2s
3. min(3,1,4,1,5) = 1, max(3,1,4,1,5) = 5
4. help(min) and help(max) produce output
5. Existing acceptance tests: `bash tests/acceptance.sh && bash tests/acceptance-wins.sh`
</verification>

<success_criteria>
- T_rn memoization eliminates exponential blowup; T(0,30,50) is fast
- min/max builtins work with 2+ integer arguments
- All existing tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/42-garvan-tutorial-coverage/42-01-SUMMARY.md`
</output>
