---
phase: 17-help-help-func
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/repl.h
autonomous: true

must_haves:
  truths:
    - "help prints general usage and flat list of all built-ins"
    - "help(func) prints signature + one-line description for known function"
    - "help(unknown) prints short message: unknown function: unknown"
  artifacts:
    - path: src/repl.h
      provides: help and help(func) built-in
      contains: "help", "dispatchBuiltin"
  key_links:
    - from: src/repl.h
      to: help table and help branch in dispatchBuiltin
---

<objective>
Add help and help(func) as a built-in in repl.h. help() shows general usage and flat list of all built-in names. help(name) shows signature + one-line description for known functions, or "unknown function: name" for unknown. Coverage: all built-ins (aqprod, etaq, theta2/3/4, theta, qbin, tripleprod, quinprod, winquist, sift, T, prodmake, etamake, jacprodmake, jac2prod, qfactor, series, coeffs, set_trunc, findhom, findnonhom, findhomcombo, findnonhomcombo, findpoly, legendre, sigma, subs_q, sum, add).

Purpose: QOL-02, QOL-03
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/17-help-help-func/17-CONTEXT.md
@.planning/phases/17-help-help-func/17-RESEARCH.md
@src/repl.h
</context>

<tasks>

<task type="auto">
  <name>Add help table and help built-in in dispatchBuiltin</name>
  <files>src/repl.h</files>
  <action>
1. Add a static help table (before dispatchBuiltin or as a helper): map from function name to (signature, description). Include all built-ins with signature + one-line description per CONTEXT. Use a simple structure: vector of (name, sig, desc) or map&lt;string,pair&lt;string,string&gt;&gt;.

2. In dispatchBuiltin, add a branch for name == "help" BEFORE the final throw:
   - If args.size() == 0: Print brief usage (e.g. "q-series REPL. Commands: expr, var := expr, help, help(func). Built-ins:") then print flat list of all names from the table. Return DisplayOnly{}.
   - If args.size() == 1 and args[0]->tag == Expr::Tag::Var: Lookup args[0]->varName in table. If found: print "signature — description". If not found: print "unknown function: " + varName to stderr or cout. Return DisplayOnly{}.
   - Else: throw std::runtime_error("help or help(func) expects 0 or 1 argument");

3. Place the help branch after subs_q and before the final throw.
  </action>
  <verify>
- help → shows usage and list of built-ins
- help(etaq) → shows etaq(k,T) — eta product ...
- help(nonexistent) → unknown function: nonexistent
  </verify>
  <done>help and help(func) work per success criteria.</done>
</task>

</tasks>

<verification>
- Build succeeds
- help prints general help and flat built-in list
- help(prodmake) prints signature + description
- help(bogus) prints "unknown function: bogus"
</verification>

<success_criteria>
1. help shows general usage and list of built-ins
2. help(func) shows signature + description for known function
3. help(unknown) gives short "unknown function: unknown" message
</success_criteria>

<output>
After completion, create `.planning/phases/17-help-help-func/17-01-SUMMARY.md`
</output>
