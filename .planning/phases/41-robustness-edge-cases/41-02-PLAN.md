---
phase: 41-robustness-edge-cases
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/repl.h
  - tests/acceptance-robustness.sh
autonomous: true

must_haves:
  truths:
    - "Integer division by zero in expressions throws 'division by zero' error"
    - "std::bad_variant_access never leaks to user — replaced with descriptive error"
    - "Unknown built-in 'etamke' suggests 'etamake'"
    - "x := mobius(6) works — integer result stored as constant series"
    - "All existing acceptance tests still pass"
  artifacts:
    - path: "src/repl.h"
      provides: "Division by zero guard, toSeries helper, Levenshtein suggestions, integer assignment"
      contains: "levenshteinDistance"
    - path: "tests/acceptance-robustness.sh"
      provides: "Acceptance tests for all 9 robustness fixes"
      min_lines: 60
  key_links:
    - from: "src/repl.h toSeries()"
      to: "evalExpr BinOp/UnOp/Sum"
      via: "replaces bare std::get<Series>"
      pattern: "toSeries\\(eval"
    - from: "src/repl.h levenshteinDistance()"
      to: "dispatchBuiltin unknown name throw"
      via: "suggestions from getHelpTable keys"
      pattern: "levenshteinDistance"
    - from: "src/repl.h evalStmt"
      to: "int64_t variant branch"
      via: "Series::constant(Frac(val)) wrapping"
      pattern: "holds_alternative<int64_t>"
---

<objective>
Fix integer division by zero, replace bare std::get<Series> with safe helper, add Levenshtein-based builtin suggestions, enable integer-valued builtin assignment, and create the acceptance test script for all 9 robustness fixes.

Purpose: Fix the remaining critical bug (div by zero) and all 3 medium-severity usability issues, plus provide regression test coverage for the entire phase.
Output: Hardened repl.h + comprehensive acceptance test script.
</objective>

<execution_context>
@.planning/phases/41-robustness-edge-cases/41-CONTEXT.md
@.planning/phases/41-robustness-edge-cases/41-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/repl.h
@tests/acceptance-wins.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix division by zero, safe variant access, Levenshtein suggestions, and integer assignment</name>
  <files>src/repl.h</files>
  <action>
Four changes to `src/repl.h`, all independent:

**1a. Integer division by zero guard (ROBUST-03, line 226):**

In `evalToInt`, `case BinOp::Div:` (line 226), replace:
```cpp
case BinOp::Div: return l / r;
```
with:
```cpp
case BinOp::Div:
    if (r == 0) throw std::runtime_error("division by zero");
    return l / r;
```

**1b. Safe variant access helper (ROBUST-07):**

Add a `toSeries` helper function near the top of the eval section (around line 205, before `evalToInt`):
```cpp
inline Series toSeries(const EvalResult& r, const char* context) {
    if (std::holds_alternative<Series>(r))
        return std::get<Series>(r);
    if (std::holds_alternative<int64_t>(r))
        return Series::constant(Frac(std::get<int64_t>(r)));
    throw std::runtime_error(std::string(context) + ": expected series expression");
}
```
This helper also auto-promotes int64_t to constant Series, which is a nice bonus.

Replace all 4 bare `std::get<Series>(eval(...))` calls in `evalExpr`:
- Line 738: `Series l = std::get<Series>(eval(e->left.get(), env, sumIndices));` → `Series l = toSeries(eval(e->left.get(), env, sumIndices), "binary op");`
- Line 739: `Series r = std::get<Series>(eval(e->right.get(), env, sumIndices));` → `Series r = toSeries(eval(e->right.get(), env, sumIndices), "binary op");`
- Line 753: `Series s = std::get<Series>(eval(e->operand.get(), env, sumIndices));` → `Series s = toSeries(eval(e->operand.get(), env, sumIndices), "unary op");`
- Line 767: `Series term = std::get<Series>(eval(e->body.get(), env, idx));` → `Series term = toSeries(eval(e->body.get(), env, idx), "sum body");`

**1c. Levenshtein suggestions for unknown builtins (ROBUST-08):**

Add a Levenshtein distance function near the top of repl.h (near other helpers, before `dispatchBuiltin`):
```cpp
inline int levenshteinDistance(const std::string& a, const std::string& b) {
    size_t m = a.size(), n = b.size();
    std::vector<size_t> prev(n + 1), curr(n + 1);
    for (size_t j = 0; j <= n; ++j) prev[j] = j;
    for (size_t i = 1; i <= m; ++i) {
        curr[0] = i;
        for (size_t j = 1; j <= n; ++j) {
            size_t cost = (a[i-1] == b[j-1]) ? 0 : 1;
            curr[j] = std::min({prev[j] + 1, curr[j-1] + 1, prev[j-1] + cost});
        }
        std::swap(prev, curr);
    }
    return static_cast<int>(prev[n]);
}
```

Replace the throw at line 709:
```cpp
throw std::runtime_error(runtimeErr(name, "unknown built-in"));
```
with:
```cpp
{
    const auto& table = getHelpTable();
    std::vector<std::pair<int, std::string>> suggestions;
    for (const auto& [key, _] : table) {
        int d = levenshteinDistance(name, key);
        if (d <= 3)
            suggestions.push_back({d, key});
    }
    std::sort(suggestions.begin(), suggestions.end());
    std::string msg = "unknown built-in '" + name + "'.";
    if (!suggestions.empty()) {
        msg += " Did you mean:";
        for (size_t i = 0; i < std::min(suggestions.size(), size_t(2)); ++i)
            msg += " " + suggestions[i].second;
        msg += "?";
    } else {
        msg += " No close matches found.";
    }
    throw std::runtime_error(msg);
}
```

Per locked decision: Levenshtein distance, up to 2 suggestions with distance <= 3, exact message format.

**1d. Integer assignment (ROBUST-09, line ~1115):**

In `evalStmt`, after the `std::vector<JacFactor>` handler (line 1115) and before the throw (line 1117), add:
```cpp
if (std::holds_alternative<int64_t>(res)) {
    int64_t val = std::get<int64_t>(res);
    env.env[s->assignName] = Series::constant(Frac(val));
    return res;
}
```

Per locked decision: wrap int64_t in `Series::constant(Frac(value))` and store. `DisplayOnly` still cannot be assigned (the existing throw at the end handles that).
  </action>
  <verify>
Build: `g++ -std=c++20 -O2 -Wall -Wextra -Wpedantic -o qseries main.cpp` — zero new warnings.
Test manually via pipe:
- `echo "1/0" | ./qseries` → prints "Error: division by zero"
- `echo "etamke(1,50)" | ./qseries` → prints "Error: unknown built-in 'etamke'. Did you mean: etamake?"
- `printf 'x := mobius(6)\nseries(x, 10)\n' | ./qseries` → stores and displays constant series
- Run `bash tests/acceptance.sh` — all pass
  </verify>
  <done>Division by zero caught, bad_variant_access eliminated, unknown builtins suggest alternatives, integer assignment works.</done>
</task>

<task type="auto">
  <name>Task 2: Create acceptance test script for all 9 robustness fixes</name>
  <files>tests/acceptance-robustness.sh</files>
  <action>
Create `tests/acceptance-robustness.sh` following the pattern in `tests/acceptance-wins.sh`:
- Shebang `#!/usr/bin/env bash`, `set -e`
- Binary detection (dist/qseries.exe, dist/qseries, ./qseries.exe, ./qseries)
- `run()` helper: `printf '%s\n' "$@" | "$BIN" 2>&1`
- PASS/FAIL counters

Tests (each uses `run "command" | grep -q "expected"` pattern):

1. **etaq k<=0**: `run "etaq(0, 50)" | grep -q "k must be positive"` → PASS/FAIL
2. **sift n<=0**: `run "sift(etaq(1,30), 0, 0, 30)" | grep -q "modulus n must be positive"` → PASS/FAIL
3. **Division by zero**: `run "1/0" | grep -q "division by zero"` → PASS/FAIL
4. **Deep nesting**: Generate 300 nested parens via inline string `$(python3 -c "print('(' * 300 + '1' + ')' * 300)")` or use bash printf to build the string; test output contains "too deeply nested" → PASS/FAIL
5. **Large integer literal**: `run "99999999999999999999999" | grep -q "too large"` → PASS/FAIL
6. **pow magnitude**: `run "etaq(1,20).pow(20000)" | grep -q "magnitude too large"` → PASS/FAIL
7. **Unknown builtin suggestion**: `run "etamke(1,50)" | grep -q "Did you mean"` → PASS/FAIL
8. **Integer assignment**: `run "x := mobius(6)" | grep -qv "Error"` (no error) → PASS/FAIL
9. **Existing tests unchanged**: Run `bash tests/acceptance.sh` — exit code 0 → PASS/FAIL

End with summary: `echo "$PASS passed, $FAIL failed"` and `exit $FAIL`.

For the deep nesting test (test 4), avoid python dependency — use bash to build the string:
```bash
DEEP=$(printf '(%.0s' $(seq 1 300))1$(printf ')%.0s' $(seq 1 300))
if run "$DEEP" | grep -q "too deeply nested"; then ...
```

For test 8 (integer assignment), verify the value is usable:
```bash
if run "x := mobius(6)" "series(x, 10)" | grep -q "^-1"; then ...
```
(`mobius(6) = 1`, so `series(x, 10)` should show `1 + O(q^10)` or just `1`.)
  </action>
  <verify>
Run: `bash tests/acceptance-robustness.sh` — all 9 tests pass, exit code 0.
Also run: `bash tests/acceptance.sh` — all existing tests still pass.
  </verify>
  <done>Acceptance test script exists covering all 9 robustness requirements; all tests pass.</done>
</task>

</tasks>

<verification>
1. Build with `-Wall -Wextra -Wpedantic` — zero new warnings
2. `echo "1/0" | ./qseries` → "Error: division by zero"
3. `echo "etamke(1,50)" | ./qseries` → "Did you mean: etamake?"
4. `printf 'x := mobius(6)\nseries(x, 10)\n' | ./qseries` → works, no error
5. `bash tests/acceptance-robustness.sh` — all 9 pass
6. `bash tests/acceptance.sh` — all existing tests pass
</verification>

<success_criteria>
- ROBUST-03 (division by zero) fixed with clear error message
- ROBUST-07 (variant access) fixed — bad_variant_access never leaks to user
- ROBUST-08 (unknown builtin) fixed — suggests closest matches via Levenshtein
- ROBUST-09 (integer assignment) fixed — integer results wrap in constant Series
- Acceptance test script covers all 9 requirements and passes
- Zero new compiler warnings
- All existing acceptance tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/41-robustness-edge-cases/41-02-SUMMARY.md`
</output>
