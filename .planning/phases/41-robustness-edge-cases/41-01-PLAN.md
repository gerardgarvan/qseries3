---
phase: 41-robustness-edge-cases
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/qfuncs.h
  - src/convert.h
  - src/series.h
  - src/parser.h
autonomous: true

must_haves:
  truths:
    - "etaq(0, 50) throws error instead of hanging"
    - "sift(f, 0, 0, 50) throws error instead of hanging"
    - "Deeply nested input (256+ parens) throws 'too deeply nested' error, no crash"
    - "Integer literal 99999999999999999999999 throws 'too large' error"
    - "pow(INT_MIN) or pow(20000) throws 'magnitude too large' error, no UB"
    - "All existing acceptance tests still pass"
  artifacts:
    - path: "src/qfuncs.h"
      provides: "etaq k>0 guard"
      contains: "etaq: k must be positive"
    - path: "src/convert.h"
      provides: "sift n>0 guard"
      contains: "sift: modulus n must be positive"
    - path: "src/series.h"
      provides: "pow exponent magnitude guard"
      contains: "pow: exponent magnitude too large"
    - path: "src/parser.h"
      provides: "recursion depth limit + integer overflow detection"
      contains: "parser: expression too deeply nested"
  key_links:
    - from: "src/qfuncs.h"
      to: "REPL try/catch"
      via: "std::runtime_error propagation"
      pattern: "throw std::runtime_error"
    - from: "src/parser.h"
      to: "REPL try/catch"
      via: "std::runtime_error propagation"
      pattern: "throw std::runtime_error"
---

<objective>
Add input validation guards to the math/parser layer: etaq k>0, sift n>0, pow magnitude limit, parser recursion depth limit, integer literal overflow detection.

Purpose: Prevent 5 of the 6 critical crash/hang bugs (the 6th — division by zero — is in repl.h, handled by Plan 02).
Output: Four hardened source files with guards that throw descriptive std::runtime_error on invalid input.
</objective>

<execution_context>
@.planning/phases/41-robustness-edge-cases/41-CONTEXT.md
@.planning/phases/41-robustness-edge-cases/41-RESEARCH.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/qfuncs.h
@src/convert.h
@src/series.h
@src/parser.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validation guards to etaq, sift, and pow</name>
  <files>src/qfuncs.h, src/convert.h, src/series.h</files>
  <action>
Three 1-3 line guards at function entry points:

1. **src/qfuncs.h line 177** — `etaq(const Series& q, int k, int T)`: Add at the top of the function body (before the `standardQ` check):
```cpp
if (k <= 0)
    throw std::runtime_error("etaq: k must be positive, got " + std::to_string(k));
```

2. **src/convert.h line 13** — `sift(const Series& f, int n, int k, int T)`: Add at the top of the function body (before the while loop):
```cpp
if (n <= 0)
    throw std::runtime_error("sift: modulus n must be positive, got " + std::to_string(n));
```

3. **src/series.h line 209** — `pow(int n) const`: Add after the `n == 0` check and BEFORE the `n < 0` branch. This prevents `pow(INT_MIN)` from reaching `-n` (which is UB for signed int):
```cpp
if (n > 10000 || n < -10000)
    throw std::runtime_error("pow: exponent magnitude too large (limit 10000)");
```

All three use `std::runtime_error` per locked decision. The REPL's existing try/catch catches these and prints `Error: ...`.
  </action>
  <verify>
Build: `g++ -std=c++20 -O2 -Wall -Wextra -Wpedantic -o qseries main.cpp` — zero new warnings.
Test manually via pipe:
- `echo "etaq(0, 50)" | ./qseries` → prints "Error: etaq: k must be positive, got 0"
- `echo "sift(etaq(1,30), 0, 0, 30)" | ./qseries` → prints "Error: sift: modulus n must be positive, got 0"
- `echo "etaq(1,20).pow(20000)" | ./qseries` → prints "Error: pow: exponent magnitude too large (limit 10000)"
  </verify>
  <done>etaq(0,T), sift(f,0,k,T), and pow(extreme) all throw descriptive errors instead of hanging/crashing.</done>
</task>

<task type="auto">
  <name>Task 2: Add parser recursion depth limit and integer literal overflow detection</name>
  <files>src/parser.h</files>
  <action>
Two changes to `src/parser.h`:

**2a. Recursion depth limit (ROBUST-04):**

Add `int depth = 0;` as a private member of `class Parser` (line ~220, after `std::string inputStr;`).

In `parsePrimary()`, at the LPAREN handling (line ~322), add depth tracking:
```cpp
if (peek().kind == Token::Kind::LPAREN) {
    consume();
    if (++depth > 256)
        throw std::runtime_error("parser: expression too deeply nested (limit 256)");
    ExprPtr e = parseExpr(0);
    --depth;
    expect(Token::Kind::RPAREN);
    return e;
}
```
The `--depth` does not need RAII protection — once the parser throws, the Parser object is destroyed. Per locked decision: limit 256, exact error message.

**2b. Integer literal overflow detection (ROBUST-05):**

In `parsePrimary()`, at the INT token handling (line ~298-302), replace:
```cpp
int64_t v = 0;
for (char c : t.text) v = v * 10 + (c - '0');
```
with:
```cpp
int64_t v = 0;
for (char c : t.text) {
    int digit = c - '0';
    if (v > (INT64_MAX - digit) / 10)
        throw std::runtime_error("parser: integer literal too large for int64");
    v = v * 10 + digit;
}
```
Requires `#include <climits>` if not already present — check top of file. Per locked decision: exact error message, check BEFORE accumulation.
  </action>
  <verify>
Build: zero new warnings.
Test:
- `echo "((((((1))))))" | ./qseries` → parses fine (6 levels, well under 256)
- Generate a deeply nested input and pipe it: `python3 -c "print('(' * 300 + '1' + ')' * 300)" | ./qseries` → prints "Error: parser: expression too deeply nested (limit 256)"
- `echo "99999999999999999999999" | ./qseries` → prints "Error: parser: integer literal too large for int64"
- `echo "123" | ./qseries` → parses fine (normal integer)
  </verify>
  <done>Parser rejects deeply nested expressions (>256 levels) and oversized integer literals with clear error messages.</done>
</task>

</tasks>

<verification>
1. Build with `-Wall -Wextra -Wpedantic` — zero new warnings
2. `echo "etaq(0, 50)" | ./qseries` → error, not hang
3. `echo "sift(etaq(1,30), 0, 0, 30)" | ./qseries` → error, not hang
4. `echo "etaq(1,20).pow(20000)" | ./qseries` → error, not crash
5. Deep nesting test → error, not crash
6. Large integer literal → error, not silent overflow
7. Run existing acceptance tests: `bash tests/acceptance.sh` — all pass
</verification>

<success_criteria>
- Five critical bugs (ROBUST-01, 02, 04, 05, 06) fixed with descriptive error messages
- Zero new compiler warnings
- All existing acceptance tests pass unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/41-robustness-edge-cases/41-01-SUMMARY.md`
</output>
