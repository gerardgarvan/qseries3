---
phase: 04-qfuncs
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/qfuncs.h]
autonomous: true

must_haves:
  truths:
    - "etaq(q,1,T) matches Euler pentagonal (coeff ±1 at 0,1,2,5,7,12,15)"
    - "aqprod(a,q,n,T) = Π_{k=0}^{n-1} (1 - a·q^k) truncated to T"
    - "qbin returns 0 if m<0 or m>n; 1 if m==0 or m==n"
    - "divisors(n) returns sorted positive divisors; prodmake needs it"
  artifacts:
    - path: src/qfuncs.h
      provides: nthelpers, etaq, aqprod, qbin
      contains: "etaq"
  key_links:
    - from: "qfuncs.h"
      to: "series.h"
      via: "#include"
      pattern: "Series"
---

<objective>
Implement number theory helpers and core q-series building blocks in src/qfuncs.h. Per CONTEXT and RESEARCH: divisors, mobius, legendre, sigma, euler_phi; etaq(q,k,T), aqprod(a,q,n,T), qbin(m,n,T). Garvan signatures; truncate after each multiply.
</objective>

Purpose: Foundation for Phase 5 prodmake (needs divisors) and Rogers-Ramanujan (needs aqprod). etaq is workhorse; aqprod builds (q;q)_n.
Output: qfuncs.h with nthelpers + etaq, aqprod, qbin.

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/04-qfuncs/04-CONTEXT.md
@.planning/phases/04-qfuncs/04-RESEARCH.md
@SPEC.md
@src/series.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Number theory helpers</name>
  <files>src/qfuncs.h</files>
  <action>
Add to qfuncs.h (or inline in same file): divisors, mobius, legendre, sigma, euler_phi.

- **divisors(n):** std::vector<int> — sorted positive divisors; trial division 1..√n
- **mobius(n):** int — μ(n) = 0 if squared factor, (-1)^k if k distinct primes
- **legendre(a, p):** int — (a/p) = a^{(p-1)/2} mod p; 0 if p|a
- **sigma(n, k=1):** int64_t — Σ_{d|n} d^k
- **euler_phi(n):** int64_t — φ(n) via n·Π(1-1/p)

Per CONTEXT: divisors→vector<int>, mobius/legendre→int, sigma/phi→int64_t.
</action>
  <verify>divisors(12)=={1,2,3,4,6,12}; mobius(6)==1; sigma(6)==12; euler_phi(6)==2</verify>
  <done>nthelpers implemented</done>
</task>

<task type="auto">
  <name>Task 2: etaq(q, k, T)</name>
  <files>src/qfuncs.h</files>
  <action>
Implement etaq(q, k, T) = Π_{n≥1} (1 - q^{kn}) truncated to O(q^T).

- result = Series::one(T)
- For n = 1, 2, ... while k*n < T: result *= (1 - q.truncTo(T).subs_q(k*n) or equivalent); truncate to T after each multiply
- Build (1 - q^{kn}) as Series::one(T) - q.truncTo(T).qpow(kn) — need q as Series; use q built with trunc T
- Ensure result.trunc = T

Pentagonal check: etaq(q,1,20) has coeff ±1 at 0,1,2,5,7,12,15; 0 elsewhere.
</action>
  <verify>etaq(q,1,20) coeffs at pentagonal numbers; 1/etaq(q,1,20) has partition-like coeffs</verify>
  <done>etaq implemented; truncate after each factor</done>
</task>

<task type="auto">
  <name>Task 3: aqprod(a, q, n, T)</name>
  <files>src/qfuncs.h</files>
  <action>
Implement aqprod(a, q, n, T) = (a;q)_n = Π_{k=0}^{n-1} (1 - a·q^k).

- aqprod(a,q,0,T) = Series::one(T)
- result = 1; for k=0..n-1: factor = 1 - a * q^k; result *= factor; truncate to T
- q^k: use q.pow(k) with q truncated to T; a and q are Series
- result.trunc = T
</action>
  <verify>aqprod(q,q,5,T) = (1-q)(1-q²)...(1-q⁵); aqprod(q,q,0,T) = 1</verify>
  <done>aqprod implemented</done>
</task>

<task type="auto">
  <name>Task 4: qbin(m, n, T)</name>
  <files>src/qfuncs.h</files>
  <action>
Implement qbin(m, n, T) = [n;m]_q. Use product formula to avoid series division:

[n;m]_q = Π_{i=1}^{m} (1 - q^{n-m+i}) / (1 - q^i)

- Edge cases: return Series::zero(T) if m<0 or m>n; return Series::one(T) if m==0 or m==n
- Each step: multiply by (1 - q^{n-m+i}), divide by (1 - q^i) via inverse
- C++ API: qbin(const Series& q, int m, int n, int T) — Garvan uses q first; q implicit in REPL
</action>
</action>
  <verify>qbin edge cases; qbin(q,1,3,T) = 1+q+q²; qbin(q,0,n,T)=1</verify>
  <done>qbin implemented</done>
</task>

</tasks>

<verification>
- g++ compiles with #include "qfuncs.h"
- etaq(q,1,20) pentagonal coeffs; aqprod(q,q,5,20); qbin edge cases
</verification>

<success_criteria>
- nthelpers work; etaq, aqprod, qbin per CONTEXT
- Truncation propagated; truncate after each multiply
- Ready for 04-02 (theta)
</success_criteria>

<output>
After completion, create `.planning/phases/04-qfuncs/04-01-SUMMARY.md`
</output>
