---
phase: 04-qfuncs
plan: 02
type: execute
wave: 2
depends_on: [04-01]
files_modified: [src/qfuncs.h]
autonomous: true

must_haves:
  truths:
    - "theta2 returns θ₂/q^{1/4} with coeff 2 at n(n+1)"
    - "theta3: coeff[0]=1, coeff[n²]+=2 for n≥1"
    - "theta4: same as theta3 with alternating signs"
    - "theta(z,q,T) = Σ z^i q^{i²} for i=-T..T"
  artifacts:
    - path: src/qfuncs.h
      provides: theta2, theta3, theta4, theta
      contains: "theta2"
  key_links:
    - from: "theta2/3/4"
      to: "Series"
      via: "return Series"
      pattern: "Series"
---

<objective>
Add theta functions to qfuncs.h. Per CONTEXT: theta2(q,T) returns θ₂/q^{1/4} (integer exponents); theta3, theta4, theta per Garvan.
</objective>

Purpose: Theta functions for etamake, findhom, Gauss AGM (Phase 6–8). theta2 uses integer exponents only.
Output: theta2, theta3, theta4, theta in qfuncs.h.

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/04-qfuncs/04-CONTEXT.md
@.planning/phases/04-qfuncs/04-RESEARCH.md
@SPEC.md
@src/qfuncs.h
@src/series.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: theta2(q, T)</name>
  <files>src/qfuncs.h</files>
  <action>
Implement theta2(q, T). Returns θ₂(q)/q^{1/4} with integer exponents.

- coeff[n(n+1)] = 2 for n ≥ 0 while n(n+1) < T
- coeff[0] = 2 (n=0 gives exponent 0)
- Build Series with q as base; exponents n(n+1) = 0,2,6,12,20,...
- result.trunc = T

Note: Garvan returns full θ₂; we divide out q^{1/4} for integer exponents.
</action>
  <verify>theta2(q,T).coeff(0)==2; theta2(q,T).coeff(2)==2</verify>
  <done>theta2 implemented</done>
</task>

<task type="auto">
  <name>Task 2: theta3(q, T), theta4(q, T)</name>
  <files>src/qfuncs.h</files>
  <action>
Implement theta3 and theta4.

**theta3(q, T):** θ₃ = 1 + 2Σ_{n≥1} q^{n²}
- coeff[0] = 1; for n=1,2,... while n²<T: coeff[n²] += 2

**theta4(q, T):** θ₄ = 1 + 2Σ_{n≥1} (-1)^n q^{n²}
- coeff[0] = 1; for n=1,2,... while n²<T: coeff[n²] += 2*(-1)^n

q is Series (for subs_q support: theta3(q.subs_q(2), T) = theta3(q²)).
</action>
  <verify>theta3 coeff 1 at 0, 2 at 1,4,9; theta4 alternating at squares</verify>
  <done>theta3, theta4 implemented</done>
</task>

<task type="auto">
  <name>Task 3: theta(z, q, T)</name>
  <files>src/qfuncs.h</files>
  <action>
Implement theta(z, q, T) = Σ_{i=-T}^{T} z^i q^{i²}.

- Iterate i from -T to T; add z.pow(i) * q.pow(i²) to result (scaled appropriately)
- Handle negative i: z.pow(-i) = z.inverse().pow(i)
- result.trunc = T (or suitable trunc from q^T term)
- Ensure z has nonzero constant term for inverse when i<0
</action>
  <verify>theta(Series::constant(Frac(-1),T), q, 10) matches theta4 structure</verify>
  <done>theta implemented</done>
</task>

</tasks>

<verification>
- theta2, theta3, theta4, theta compile and return correct sparse structure
</verification>

<success_criteria>
- theta2 coeff[0]=2; theta3/4 per SPEC; theta(z,q,T) general form
- Ready for 04-03 (tripleprod, quinprod, winquist)
</success_criteria>

<output>
After completion, create `.planning/phases/04-qfuncs/04-02-SUMMARY.md`
</output>
