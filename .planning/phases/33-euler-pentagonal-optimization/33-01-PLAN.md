---
phase: 33-euler-pentagonal-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/qfuncs.h]
autonomous: true

must_haves:
  truths:
    - "etaq(1,T) produces identical coefficients to the naive product loop for all T"
    - "etaq(1,500) completes near-instantaneously (microseconds, not seconds)"
    - "etaq(k,T) for k != 1 still uses the existing product loop unchanged"
    - "All existing acceptance tests pass (10 core + supplemental)"
  artifacts:
    - path: "src/qfuncs.h"
      provides: "Pentagonal fast path inside etaq()"
      contains: "k == 1 && standardQ"
  key_links:
    - from: "src/qfuncs.h"
      to: "etaq_cache"
      via: "pentagonal result cached by existing memoization"
      pattern: "etaq_cache.*k.*T"
---

<objective>
Add Euler pentagonal number theorem fast path to etaq(1,T) inside src/qfuncs.h.

Purpose: etaq(1,T) currently performs T-1 Series multiplications at O(T²) total cost. Euler's pentagonal theorem gives the coefficients directly — all are 0, +1, or -1 at generalized pentagonal numbers k(3k±1)/2 — reducing cost to O(√T). This makes etaq(1,500) near-instantaneous.

Output: Modified src/qfuncs.h with pentagonal fast path; all tests passing.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-euler-pentagonal-optimization/33-RESEARCH.md
@.planning/phases/32-etaq-memoization/32-01-SUMMARY.md
@src/qfuncs.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement pentagonal fast path in etaq()</name>
  <files>src/qfuncs.h</files>
  <action>
Modify the `etaq()` function in src/qfuncs.h to add a pentagonal fast path. The change goes between the cache lookup and the existing product loop.

Current structure (lines 98-120):
```cpp
inline Series etaq(const Series& q, int k, int T) {
    bool standardQ = ...;
    if (standardQ) { /* cache lookup */ }
    Series result = Series::one(T);        // ← replace this block
    for (int n = 1; k * n < T; ++n) { ... }  // ← with conditional
    result.trunc = T;
    if (standardQ) { /* cache store */ }
    return result;
}
```

Replace the unconditional product loop with a conditional:

```cpp
Series result;
if (k == 1 && standardQ) {
    result = Series::zero(T);
    result.trunc = T;
    for (int j = 0; ; ++j) {
        int p1 = j * (3 * j - 1) / 2;
        int p2 = j * (3 * j + 1) / 2;
        if (p1 >= T && p2 >= T) break;
        Frac sign(j % 2 == 0 ? 1 : -1);
        if (p1 < T) result.setCoeff(p1, sign);
        if (p2 < T && p2 != p1) result.setCoeff(p2, sign);
    }
} else {
    result = Series::one(T);
    for (int n = 1; k * n < T; ++n) {
        Series qkn = q.truncTo(T).pow(k * n);
        Series factor = Series::one(T) - qkn;
        result = (result * factor).truncTo(T);
    }
    result.trunc = T;
}
```

Critical correctness points:
- j=0 gives p1=p2=0; the `p2 != p1` guard prevents double-setting
- Sign is `(-1)^j`: +1 for even j, -1 for odd j
- Loop terminates when BOTH p1 >= T AND p2 >= T
- Only triggers when k==1 AND standardQ (pentagonal theorem is for ∏(1-q^n))
- The cache store after this block is unchanged — pentagonal result gets cached normally

Expected coefficients for verification: coeff(0)=1, coeff(1)=-1, coeff(2)=-1, coeff(5)=1, coeff(7)=1, coeff(12)=-1, coeff(15)=-1, all others 0.
  </action>
  <verify>
Build: `g++ -std=c++20 -O2 -o qseries src/main.cpp` must succeed with no warnings.

Quick smoke test:
```bash
echo 'etaq(1, 15)' | ./qseries
```
Expected output should contain: `1 - q - q^2 + q^5 + q^7 - q^12 + O(q^15)`
  </verify>
  <done>etaq() contains pentagonal fast path; build succeeds; etaq(1,15) output matches expected pentagonal coefficients</done>
</task>

<task type="auto">
  <name>Task 2: Run all acceptance tests and verify performance</name>
  <files></files>
  <action>
Run ALL existing acceptance tests to confirm nothing is broken:

1. Core acceptance: `bash tests/acceptance.sh`
2. Supplemental tests: `bash tests/acceptance-wins.sh`, `bash tests/acceptance-optional-args.sh`, `bash tests/acceptance-suppress-output.sh`, `bash tests/acceptance-mprodmake.sh`, `bash tests/acceptance-checkprod-checkmult.sh`, `bash tests/acceptance-findmaxind.sh`, `bash tests/acceptance-history.sh`

All must pass with zero failures.

Performance check — run a timing comparison:
```bash
echo -e 'etaq(1,500)\n' | timeout 5 ./qseries
```
This must complete well under 0.5s (should be near-instantaneous with pentagonal path). If it hangs or times out, the fast path is not triggering.

Also verify k!=1 still works:
```bash
echo -e 'etaq(2,50)\netaq(7,50)' | ./qseries
```
Must produce non-empty series output (uses old product loop path).
  </action>
  <verify>
All acceptance test scripts exit 0. `etaq(1,500)` completes in under 0.5s. `etaq(2,50)` and `etaq(7,50)` produce correct output.
  </verify>
  <done>All acceptance tests pass; etaq(1,500) is near-instant; etaq(k,T) for k!=1 unchanged</done>
</task>

</tasks>

<verification>
1. Build succeeds: `g++ -std=c++20 -O2 -o qseries src/main.cpp`
2. Pentagonal coefficients correct: `etaq(1,15)` = 1 - q - q² + q⁵ + q⁷ - q¹² + O(q¹⁵)
3. All acceptance tests pass (core + supplemental)
4. Performance: `etaq(1,500)` completes in microseconds, not seconds
5. Non-pentagonal cases unchanged: `etaq(2,50)`, `etaq(7,50)` produce correct results
</verification>

<success_criteria>
- src/qfuncs.h contains `if (k == 1 && standardQ)` pentagonal fast path
- Pentagonal result is byte-for-byte identical to naive product (exact rational arithmetic)
- etaq(1,500) completes near-instantaneously
- All existing acceptance tests pass with zero regressions
- Cache interaction unchanged (pentagonal result stored in etaq_cache, subsequent calls hit cache)
</success_criteria>

<output>
After completion, create `.planning/phases/33-euler-pentagonal-optimization/33-01-SUMMARY.md`
</output>
