---
phase: 06-convert-extended
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified: [src/convert.h, src/main.cpp]
autonomous: true

must_haves:
  truths:
    - "jacprodmake(RR, T) yields JAC(0,5,∞)/JAC(1,5,∞) (TEST-04)"
    - "jacprodmake(E0, 50) on sifted etaq(1) yields JAC(2,5,∞)·JAC(0,5,∞)/JAC(1,5,∞) (TEST-09)"
    - "jac2prod(jac_expr) returns string in (q^a;q^b)_∞ notation"
    - "jac2series(jac_expr, T) returns Series equal to product of JAC factors to O(q^T)"
  artifacts:
    - path: src/convert.h
      provides: jacprodmake, jac2prod, jac2series
      contains: "jacprodmake(", "jac2prod(", "jac2series("
    - path: src/main.cpp
      provides: TEST-04 and TEST-09
  key_links:
    - from: jacprodmake
      to: prodmake
      via: run prodmake(f,T), set e[n]=-a[n], then period detection
    - from: jac2series
      to: aqprod or product loop
      via: build (q^a;q^b)_∞ truncated to T for each JAC factor
---

<objective>
Implement jacprodmake(f, T), jac2prod(jac_expr), and jac2series(jac_expr, T) in convert.h so that Rogers-Ramanujan and Euler pentagonal dissection are identified as JAC products (TEST-04, TEST-09).

Purpose: Jacobi product identification is required for SPEC CONVERT-03 and acceptance tests.
Output: convert.h with jacprodmake (80% period + verify), jac2prod (string), jac2series (Series); main.cpp tests for RR and E0.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-convert-extended/06-CONTEXT.md
@.planning/phases/06-convert-extended/06-RESEARCH.md
@src/convert.h
@src/qfuncs.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement jacprodmake with 80% period and verify</name>
  <files>src/convert.h</files>
  <action>
Add jacprodmake(f, T) to convert.h. (1) Call prodmake(f, T) to get a[n]. Define e[n] = -a[n] (power of (1-q^n)). (2) Search for period b: try b = 2,3,... up to ~T/2. For each b, count n in [1, T-1-b] for which e[n+b]==e[n]; require count &gt;= 80% of (T-1-b) (80% match per CONTEXT). If no b qualifies, return failure (empty or optional). (3) Verify: build series from one-period pattern e[1..b] interpreted as JAC(a,b,∞) factors — use jac2series on the parsed list — and compare to f to O(q^T). If mismatch, reject or try next b. (4) Decompose one period into JAC factors: JAC(0,b) contributes only n≡0 (mod b); JAC(a,b) for 0&lt;a&lt;b contributes n≡a, b-a, b (mod b). Solve for exponents of each JAC(0,b), JAC(1,b), ... from e[1..b]. Return structured list: e.g. std::vector of (a, b, exponent) or struct with (a, b, Frac exp). Use Frac for exponent to match prodmake; if non-integer, jac2series can still use it or round per RESEARCH.
  </action>
  <verify>Build. jacprodmake(RogersRamanujan_series, 40) returns list containing JAC(0,5,∞) and JAC(1,5,∞) with correct signs (RR = JAC(0,5,∞)/JAC(1,5,∞)). jacprodmake(sift(etaq(1,500), 5, 0, 499), 50) returns JAC(2,5,∞)·JAC(0,5,∞)/JAC(1,5,∞).</verify>
  <done>jacprodmake returns list of (a, b, exponent); 80% periodicity and verify-by-reconstruction used; TEST-04 and TEST-09 patterns identified.</done>
</task>

<task type="auto">
  <name>Task 2: Implement jac2prod and jac2series</name>
  <files>src/convert.h</files>
  <action>
Add jac2prod(jac_expr) and jac2series(jac_expr, T). jac_expr is the list returned by jacprodmake (e.g. vector of (a,b,exponent)). jac2prod: produce string in (q^a;q^b)_∞ notation, e.g. "1 / ((q,q^5)_∞ (q^4,q^5)_∞)" for RR (Garvan Output 14). Handle product and quotient from positive/negative exponents. jac2series: for each (a,b,e), build (q^a;q^b)_∞ = Π_{j≥0} (1 - q^{a+jb}) to O(q^T); for JAC(a,b,∞) with a&gt;0 also include (q^{b-a};q^b)_∞ and (q^b;q^b)_∞; raise to exponent e and multiply all. Use aqprod or a manual loop: (q^a;q^b)_∞ = product over j of (1 - q^{a+jb}) while a+jb &lt; T. Series q = Series::q(T). Multiply resulting series; respect truncation.
  </action>
  <verify>jac2series(jacprodmake(RR,40), 50) equals RR to O(q^40). jac2prod on RR result matches "1 / ((q,q^5)_∞ (q^4,q^5)_∞)" or equivalent.</verify>
  <done>jac2prod returns human-readable (q^a;q^b)_∞ string; jac2series reconstructs Series from JAC list; reconstruction matches original.</done>
</task>

<task type="auto">
  <name>Task 3: Add main.cpp tests TEST-04 and TEST-09</name>
  <files>src/main.cpp</files>
  <action>
In main.cpp: (1) TEST-04: Build Rogers-Ramanujan series (RR = sum over n of q^(n²)/(q;q)_n truncated, e.g. n=0..8, T=50). Call jacprodmake(RR, 40). CHECK that result is non-empty and represents JAC(0,5,∞)/JAC(1,5,∞). Call jac2prod on result and CHECK string contains expected (q,q^5)_∞ and (q^4,q^5)_∞. (2) TEST-09: EULER = etaq(q, 1, 500); E0 = sift(EULER, 5, 0, 499); jacprodmake(E0, 50). CHECK result matches JAC(2,5,∞)·JAC(0,5,∞)/JAC(1,5,∞). Use existing CHECK macro and Series construction from existing main.cpp.
  </action>
  <verify>g++ -std=c++20 -O2 -o qseries main.cpp &amp;&amp; ./qseries; TEST-04 and TEST-09 pass.</verify>
  <done>main.cpp includes TEST-04 (RR → JAC) and TEST-09 (E0 → JAC); both pass.</done>
</task>

</tasks>

<verification>
- Rogers-Ramanujan series built as in 05-01 (sum q^(n²)/(q;q)_n); jacprodmake yields period 5 and JAC(0,5)/JAC(1,5).
- jac2series(jacprodmake(f,T), T) matches f to truncation.
- E0 = sift(etaq(1,500), 5, 0, 499); jacprodmake(E0, 50) yields JAC(2,5)·JAC(0,5)/JAC(1,5).
</verification>

<success_criteria>
- jacprodmake, jac2prod, jac2series in convert.h; TEST-04 and TEST-09 pass; 80% period and verify-by-reconstruction used.
</success_criteria>

<output>
After completion, create .planning/phases/06-convert-extended/06-02-SUMMARY.md
</output>
