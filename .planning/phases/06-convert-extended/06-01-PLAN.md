---
phase: 06-convert-extended
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/convert.h, src/main.cpp]
autonomous: true

must_haves:
  truths:
    - "sift(f, n, k, T) returns Series with coeff[i] = f.coeff(n*i+k) and correct trunc"
    - "etamake identifies theta3/theta4 as eta products (TEST-03)"
    - "etamake reports failure after max iterations when input is not an eta product"
    - "Rødseth identity holds: sift(PD,5,1,199) then etamake yields η(5τ)³·η(2τ)²/(η(10τ)·η(τ)⁴) (TEST-06)"
  artifacts:
    - path: src/convert.h
      provides: sift and etamake
      contains: "sift(", "etamake("
    - path: src/main.cpp
      provides: TEST-03, TEST-06, and sift/etamake checks
  key_links:
    - from: etamake
      to: etaq
      via: multiply g by etaq(q,k,T)^c to cancel q^k term
    - from: sift
      to: Series.coeff
      via: read f.coeff(n*i+k) for i=0,1,...
---

<objective>
Implement sift(f, n, k, T) and etamake(f, T) in convert.h so that coefficient extraction and eta-product identification work. Enables TEST-03 (etamake on theta3/theta4) and the sift step for TEST-06 (Rødseth) and TEST-09 (Euler pentagonal).

Purpose: Product identification starts with eta; sift is required for Rødseth and Euler tests.
Output: convert.h with sift and etamake; main.cpp tests for sift and etamake (theta3, theta4).
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-convert-extended/06-CONTEXT.md
@.planning/phases/06-convert-extended/06-RESEARCH.md
@src/convert.h
@src/qfuncs.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement sift in convert.h</name>
  <files>src/convert.h</files>
  <action>
Add sift(const Series&amp; f, int n, int k, int T) to convert.h (after prodmake). Signature per CONTEXT: n = modulus, k = residue (0 ≤ k &lt; n). Return Series where exponent i has coefficient f.coeff(n*i+k). Effective trunc = floor((T-1-k)/n)+1. Loop i = 0,1,... while n*i+k &lt; T; set result.coeff(i) = f.coeff(n*i+k); set result.trunc to that length. Use Series with std::map&lt;int,Frac&gt; and trunc; do not use prodmake or eta. Include &lt;vector&gt; if needed for any intermediate; prefer existing Series API.
  </action>
  <verify>Build with g++ -std=c++20 -O2 -o qseries main.cpp. Call sift(etaq(q,1,50), 5, 0, 49) and assert result.trunc and coeffs match expected (e.g. first coeff = f.coeff(0)).</verify>
  <done>sift(f, n, k, T) returns Series Σ_i a_{n·i+k} q^i with correct trunc; no build errors.</done>
</task>

<task type="auto">
  <name>Task 2: Implement etamake in convert.h with max iter and failure report</name>
  <files>src/convert.h</files>
  <action>
Add etamake(f, T) to convert.h. Algorithm (06-RESEARCH, SPEC §5.2): (1) Normalize g = f/f.coeff(minExp), track leading q-power if minExp &gt; 0. (2) Find smallest exponent k &gt; 0 with g.coeff(k) nonzero → c. (3) If c is non-integer (Frac with den != 1), treat as failure: return empty and report "not an eta product". (4) Multiply g by etaq(q, k, T).pow(c) — use integer c; record (k, -c) as eta exponent e_k. (5) Repeat until g is constant 1 or max_iter reached. Cap iterations at max_iter = 2*T (per CONTEXT). On max iter without g=1, return empty list and report "not an eta product". Return type: e.g. std::vector&lt;std::pair&lt;int,Frac&gt;&gt; for (k, e_k); plus optional human-readable string η(kτ)^{e_k} for display. For etaq call: need Series q = Series::q(T); use etaq(q, k, T) from qfuncs.h. Propagate truncation in g after each multiply.
  </action>
  <verify>Build; etamake(theta3(q,100), 100) → eta-product matching TEST-03 (η(2τ)^5/(η(4τ)^2 η(τ)^2)); etamake(theta4(q,100), 100) → η(τ)^2/η(2τ). Non-eta input hits max iter and returns empty/failure.</verify>
  <done>etamake returns list of (k,e_k) for theta3/theta4; failure path returns empty and reports; max iter 2*T enforced.</done>
</task>

<task type="auto">
  <name>Task 3: Add main.cpp tests for sift, etamake (TEST-03), and Rødseth (TEST-06)</name>
  <files>src/main.cpp</files>
  <action>
In main.cpp (existing test section): (1) Add test that sift(series, 5, 0, T) yields expected trunc and first few coefficients. (2) Add TEST-03: build theta3 and theta4 (theta3(q,100), theta4(q,100)), call etamake on each, CHECK that result is non-empty and that the eta exponent list matches expected (theta3 → η(2τ)^5/(η(4τ)^2 η(τ)^2), theta4 → η(τ)^2/η(2τ)). Use existing CHECK macro. (3) Add TEST-06 (Rødseth): build PD = etaq(q,2,200)/etaq(q,1,200), PD1 = sift(PD, 5, 1, 199), call etamake(PD1, 38), CHECK result is non-empty and equals Rødseth eta product η(5τ)³·η(2τ)²/(η(10τ)·η(τ)⁴) — i.e. eta exponents (5,3), (2,2), (10,-1), (1,-4) or equivalent. (4) Optionally call etamake on a non-eta series and assert failure report / empty result.
  </action>
  <verify>g++ -std=c++20 -O2 -o qseries main.cpp &amp;&amp; ./qseries exits 0; TEST-03 and TEST-06 checks pass.</verify>
  <done>main.cpp includes sift and etamake tests; TEST-03 (theta3, theta4 etamake) and TEST-06 (Rødseth) pass.</done>
</task>

</tasks>

<verification>
- sift(etaq(1,T), 5, 0, T-1) has trunc = floor((T-2)/5)+1.
- etamake(theta3(q,100), 100) produces (2,5), (4,-2), (1,-2) or equivalent normalized to Garvan form.
- etamake(theta4(q,100), 100) produces (1,2), (2,-1).
- TEST-06: PD = etaq(q,2,200)/etaq(q,1,200); PD1 = sift(PD, 5, 1, 199); etamake(PD1, 38) → Rødseth η(5τ)³·η(2τ)²/(η(10τ)·η(τ)⁴).
- Non-eta input: etamake(1+q+q*q, 20) hits max iter and returns empty/failure.
</verification>

<success_criteria>
- sift and etamake implemented in convert.h; both used from main.cpp.
- TEST-03 (etamake on theta3, theta4) and TEST-06 (Rødseth: sift then etamake on PD) pass; sift tested; etamake failure path exercised.
</success_criteria>

<output>
After completion, create .planning/phases/06-convert-extended/06-01-SUMMARY.md
</output>
