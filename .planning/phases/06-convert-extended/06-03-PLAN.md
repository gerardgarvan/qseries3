---
phase: 06-convert-extended
plan: 03
type: execute
wave: 2
depends_on: [06-01]
files_modified: [src/convert.h, src/main.cpp]
autonomous: true

must_haves:
  truths:
    - "T(r, n) returns Series polynomial per recurrence T(r,0)=1, T(r,1)=0, T(r,N) = -Σ qbin*T(r+2k, N-2k)"
    - "qfactor(f, T) returns q^e · num/den with num = Π(1-q^n)^{e_n} for e_n>0, den for e_n<0 (prodmake on normalized f)"
    - "qfactor(T(8,8), 20) yields q^6·(1-q^9)(1-q^10)(1-q^11)(1-q^16)/((1-q)(1-q^2)(1-q^3)(1-q^4)) (TEST-07)"
  artifacts:
    - path: src/convert.h
      provides: T(r,n) helper and qfactor
      contains: "T(", "qfactor("
    - path: src/main.cpp
      provides: TEST-07
  key_links:
    - from: T(r,n)
      to: qbin
      via: recurrence term qbin(q, k, r+2*k, T) * T(r+2*k, N-2*k)
    - from: qfactor
      to: prodmake
      via: normalize f then prodmake; interpret a[n] as num/den
---

<objective>
Implement T(r, n) and qfactor(f, T) in convert.h so that TEST-07 (qfactor(T(8,8), 20)) passes. T(r,n) is the polynomial from qseriesdoc §3.2 recurrence; qfactor writes a polynomial as q^e · product of (1-q^n) powers using prodmake.

Purpose: qfactor and T(r,n) complete CONVERT-04/05 and TEST-07.
Output: convert.h with T(r,n) and qfactor; main.cpp TEST-07.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-convert-extended/06-CONTEXT.md
@.planning/phases/06-convert-extended/06-RESEARCH.md
@src/convert.h
@src/qfuncs.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement T(r, n) in convert.h</name>
  <files>src/convert.h</files>
  <action>
Add T(r, n) function (or T_rn) returning Series. Recurrence from 06-RESEARCH and qseriesdoc §3.2: T(r, 0) = 1, T(r, 1) = 0. T(r, N) = - Σ_{k=1}^{floor(N/2)} qbin(q, k, r+2*k, T_trunc) * T(r+2*k, N-2*k). Use qbin from qfuncs.h; need Series q = Series::q(T_trunc). Truncation: use a bound large enough for T(8,8) degree 42, e.g. T_trunc = (r + 2*N)*(N+1) or 64 for T(8,8). Signature: e.g. Series T_rn(int r, int n, int T) or T(r, n, T). Implement recursively with memoization if needed to avoid repeated work; ensure qbin and Series multiplication use consistent truncation. Return polynomial Series with trunc set so all terms up to degree of T(r,n) are present.
  </action>
  <verify>Build. T(8,8) or T_rn(8,8,64) has nonzero coeff at q^6 and degree 42; first term q^6 per doc.</verify>
  <done>T(r, n) returns Series polynomial matching recurrence; T(8,8) has correct degree and leading power.</done>
</task>

<task type="auto">
  <name>Task 2: Implement qfactor in convert.h</name>
  <files>src/convert.h</files>
  <action>
Add qfactor(f, T) per CONTEXT and 06-RESEARCH. (1) Normalize: if f has minExp &gt; 0, work with g = f / f.coeff(minExp) and record leading power e = minExp; else g = f / f.coeff(0), e = 0. (2) Run prodmake(g, T) to get a[n]. (3) Output: f = q^e · (Π (1-q^n)^{-a[n]} for a[n]&lt;0) / (Π (1-q^n)^{a[n]} for a[n]&gt;0). So numerator = product over n with a[n]&lt;0 of (1-q^n)^{-a[n]}, denominator = product over n with a[n]&gt;0 of (1-q^n)^{a[n]}. Return type: struct or tuple (int q_power, std::map&lt;int,Frac&gt; num_exponents, std::map&lt;int,Frac&gt; den_exponents) or equivalent so caller can format as "q^e · num/den". Default T when omitted: 4d+3 where d = max exponent in f (f.maxExp() or from series). For this task, qfactor(f, T) with explicit T is sufficient; optional overload qfactor(f) using 4d+3. Display format: q^6·(1-q^9)(1-q^10).../((1-q)(1-q^2)...) for TEST-07.
  </action>
  <verify>qfactor(T(8,8), 20) returns q_power=6; numerator contains 9,10,11,16; denominator contains 1,2,3,4. Compare to expected TEST-07.</verify>
  <done>qfactor normalizes f, runs prodmake, returns q^e and num/den exponent maps; TEST-07 structure matches.</done>
</task>

<task type="auto">
  <name>Task 3: Add main.cpp TEST-07 (qfactor T(8,8))</name>
  <files>src/main.cpp</files>
  <action>
In main.cpp: Build t8 = T(8,8) using the new T(r,n) from convert.h (or T_rn(8,8,64)). Call qfactor(t8, 20). CHECK q_power == 6. CHECK numerator exponents include 9, 10, 11, 16 (each with positive exponent in num). CHECK denominator exponents include 1, 2, 3, 4 (each with positive exponent in den). Exact format per SPEC: q^6·(1-q^9)(1-q^10)(1-q^11)(1-q^16)/((1-q)(1-q^2)(1-q^3)(1-q^4)).
  </action>
  <verify>g++ -std=c++20 -O2 -o qseries main.cpp &amp;&amp; ./qseries; TEST-07 checks pass.</verify>
  <done>TEST-07 in main.cpp passes; qfactor(T(8,8), 20) matches expected num/den.</done>
</task>

</tasks>

<verification>
- T(8,8) is polynomial of degree 42, leading power q^6.
- qfactor output: q^6 · (1-q^9)(1-q^10)(1-q^11)(1-q^16) / ((1-q)(1-q^2)(1-q^3)(1-q^4)).
- Default T = 4d+3 optional; explicit qfactor(f, T) required.
</verification>

<success_criteria>
- T(r,n) and qfactor in convert.h; TEST-07 passes; build clean.
</success_criteria>

<output>
After completion, create .planning/phases/06-convert-extended/06-03-SUMMARY.md
</output>
