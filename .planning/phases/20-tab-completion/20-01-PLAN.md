---
phase: 20-tab-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/repl.h
autonomous: true

must_haves:
  truths:
    - "Press Tab completes partial identifier (variable or function)"
    - "Unique match: completes; multiple matches: shows options; no match: no change"
    - "Completion covers built-ins (getHelpTable keys) and user variables (env.env keys)"
    - "TTY mode: raw input for char-by-char handling; script mode: std::getline unchanged"
  artifacts:
    - path: src/repl.h
      provides: runRepl with raw readline + tab completion in TTY mode
---

<objective>
Replace std::getline in TTY mode with a custom line-editing loop that reads raw keystrokes. On Tab: extract partial identifier before cursor, prefix-match against merged candidates (getHelpTable + env.env), apply unique completion or show multiple matches. Use termios on Unix/Cygwin, SetConsoleMode on native Windows. Script/pipe mode keeps std::getline.

Purpose: QOL-06 — Tab completion for identifiers and function names
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md (QOL-06)
@.planning/phases/20-tab-completion/20-RESEARCH.md
@src/repl.h
</context>

<tasks>

<task type="auto">
  <name>Add raw-mode platform abstraction</name>
  <files>src/repl.h</files>
  <action>
1. Add platform-specific raw terminal setup/restore and char-by-char read:
   - Unix/Cygwin (#if defined(__CYGWIN__) || !defined(_WIN32)): include termios, unistd; save/restore via tcgetattr/tcsetattr; clear ICANON and ECHO; read(STDIN_FILENO, &c, 1). Restore original mode on exit (atexit or explicit in readLineRaw cleanup).
   - Native Windows (#else): include windows.h; GetStdHandle(STD_INPUT_HANDLE); GetConsoleMode/SetConsoleMode; clear ENABLE_LINE_INPUT and ENABLE_ECHO; ReadFile for 1 char. Restore mode when done.

2. Provide a helper: void setRawMode(bool on) that enters/exits raw mode. Or encapsulate: struct RawModeGuard { RawModeGuard(); ~RawModeGuard(); } so restore is automatic.

3. Provide: int readOneChar() — blocks, returns one byte (0-255) or -1 on EOF/error. Platform-specific implementation.
  </action>
  <verify>Build on Cygwin and optionally native Windows; raw mode does not crash.</verify>
  <done>Raw mode abstraction compiles and reads single chars.</done>
</task>

<task type="auto">
  <name>Implement readLineRaw() with line editing</name>
  <files>src/repl.h</files>
  <action>
1. Add std::string readLineRaw() that:
   - Enters raw mode (guard)
   - Reads chars in a loop until Enter (0x0D or 0x0A; treat \r as Enter on Windows)
   - Printable ASCII (32-126): append to line, write(c) to stdout
   - Backspace: both 0x08 and 127 — if line non-empty, pop_back, echo "\b \b"
   - Tab (0x09): call completion handler (next task)
   - Enter: exit loop, return line
   - EOF: return empty or signal break (caller handles)
   - Restore terminal on exit (destructor of guard)

2. Cursor position: assume cursor at end of line (no internal cursor). Partial identifier = last identifier token before cursor = scan backward from end while isalnum(c)||c=='_'.
  </action>
  <verify>"pro" + Tab + "d" + Tab → "prod" then "prodmake" (if unique); Backspace removes chars.</verify>
  <done>readLineRaw reads and echoes; Backspace and Enter work.</done>
</task>

<task type="auto">
  <name>Build completion candidates and completion logic</name>
  <files>src/repl.h</files>
  <action>
1. Add std::set&lt;std::string&gt; getCompletionCandidates(const Environment&amp; env):
   - Add all keys from getHelpTable()
   - Add all keys from env.env
   - Return as std::set for dedup and sorted order

2. Add completion handler: given (line, candidates) → (modifiedLine, modified) or side-effect:
   - Extract partial identifier: scan backward from line.size(); collect chars while isalnum(c)||c=='_'; first char can also be alpha or '_'
   - Prefix match: filter candidates where candidate.substr(0, prefix.size()) == prefix
   - 0 matches: no change
   - 1 match: replace partial with full; line = line.substr(0, start) + match
   - 2+ matches: print space-separated list on newline; redraw "qseries&gt; " + line; do not alter line
  </action>
  <verify>"et" + Tab → "etaq" (unique); "theta" + Tab → shows theta theta2 theta3 theta4; "xyz" + Tab → no change.</verify>
  <done>Candidates merged; prefix match; unique completes; multiple shows list.</done>
</task>

<task type="auto">
  <name>Integrate readLineRaw into runRepl</name>
  <files>src/repl.h</files>
  <action>
1. In runRepl(), when stdin_is_tty():
   - Replace std::getline(std::cin, line) with line = readLineRaw()
   - readLineRaw() needs access to env for getCompletionCandidates — pass env by reference or make it available (e.g. readLineRaw(env) or a lambda that captures env)

2. Backslash continuation: the continuation loop also uses getline. Replace those with readLineRaw(env) so Tab works on continuation lines too.

3. When !stdin_is_tty(): keep std::getline unchanged (no raw mode, no completion).

4. Ensure atexit or guard restores terminal if process exits during raw mode (e.g. Ctrl+C). Document that user may need "reset" if terminal is left in raw mode after abnormal exit.
  </action>
  <verify>Interactive: Tab completes; script: echo "q" | qseries still works; continuation + Tab works.</verify>
  <done>TTY uses readLineRaw; script uses getline; completion available in both first and continuation lines.</done>
</task>

<task type="auto">
  <name>Handle edge cases and Windows CR/LF</name>
  <files>src/repl.h</files>
  <action>
1. Windows: ReadFile may return \r (0x0D) before \n on Enter. Treat \r as end-of-line (same as \n).
2. Empty prefix (Tab at start or after non-identifier): completion with empty prefix matches all — either show full list (many items) or no change. Per QOL-06 "no match: no change" — empty prefix can be treated as no partial identifier, so no change is acceptable.
3. Identifier extraction: scan backward; stop at first non-identifier char. If we're in the middle of an identifier, we still want to complete the part before cursor. Cursor at end → whole partial identifier.
  </action>
  <verify>Enter on Windows works; Tab with no preceding identifier does not crash.</verify>
  <done>Edge cases handled.</done>
</task>

</tasks>

<verification>
- Build succeeds (g++ -std=c++20 -O2 -static)
- Interactive: Tab completes unique match (e.g. "prod" → "prodmake")
- Interactive: Tab with multiple matches prints options, does not change line
- Interactive: Tab with no match leaves line unchanged
- Completion includes built-ins (etaq, prodmake, etc.) and user vars (e.g. f := etaq(1,20); "f" + Tab → "f")
- Script/pipe mode: std::getline used; no raw mode; behavior unchanged
- Backspace works in raw line
</verification>

<success_criteria>
1. User can press Tab to complete partial identifier (variable or function)
2. Unique match: completes; multiple matches: shows options; no match: no change
3. Completion works for built-ins and user-defined variables
</success_criteria>

<output>
After completion, create `.planning/phases/20-tab-completion/20-01-SUMMARY.md`
</output>
