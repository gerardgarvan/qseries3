---
phase: 07-linalg
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/linalg.h
  - src/main.cpp
autonomous: true

must_haves:
  truths:
    - "kernel(M) returns a basis for the null space of M"
    - "For each returned vector v, M * v = 0"
    - "Empty matrix returns {}; all-zero matrix returns canonical basis e_0..e_{n-1}; full rank returns {}"
    - "Single row with one relation yields kernel dimension = ncols - 1"
  artifacts:
    - path: src/linalg.h
      provides: kernel(M), internal gauss_to_rref
      contains: kernel, gauss_to_rref (or equivalent helper)
    - path: src/main.cpp
      provides: linalg test group
      contains: kernel tests, M*v verification
  key_links:
    - from: src/linalg.h
      to: src/frac.h
      via: "#include frac.h, Frac arithmetic"
      pattern: "#include.*frac"
    - from: src/main.cpp
      to: src/linalg.h
      via: include and kernel calls
      pattern: "kernel\\("
    - from: main linalg tests
      to: kernel result
      via: matrix-vector product M*v=0
      pattern: "M.*v|verify.*0"
---

<objective>
Implement linear algebra over Q for relation finding: Gaussian elimination to RREF and kernel computation. The sole required API is `kernel(M)`, which returns a basis for the null space. Downstream consumer: Phase 8 relations.h (findhom, findnonhom).

Purpose: Enable polynomial relation discovery via matrix null-space.
Output: src/linalg.h with kernel; main.cpp linalg test group.
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-linalg/07-CONTEXT.md
@.planning/phases/07-linalg/07-RESEARCH.md
@src/frac.h
@SPEC.md (Layer 7)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create linalg.h with kernel(M)</name>
  <files>src/linalg.h</files>
  <action>
Create src/linalg.h (header-only, inline) with:

1. **Include:** frac.h; include &lt;vector&gt;.

2. **Internal helper** (static or in anonymous namespace): gauss_to_rref(A) that:
   - Takes a copy of the matrix (or modifies A in place on a copy passed by the caller).
   - Reduces to RREF using first nonzero pivot per column, row swaps, scale pivot to 1, eliminate above/below.
   - Returns vector&lt;int&gt; of pivot column indices.
   - Does not modify the caller's M.

3. **kernel(M):** `std::vector&lt;std::vector&lt;Frac&gt;&gt; kernel(std::vector&lt;std::vector&lt;Frac&gt;&gt;&amp; M);`
   - Copy M into A; call gauss_to_rref(A) to get pivot_cols.
   - Identify free columns (columns not in pivot_cols).
   - For each free column j: build kernel vector v of length ncols; set v[j]=1; back-substitute to fill v[pivot_col] for each pivot using RREF rows.
   - Return vector of kernel basis vectors.

4. **Edge cases:** Empty matrix {} or M[0].empty() → return {}. All-zero matrix → return ncols canonical basis vectors e_0..e_{n-1}. Full rank → return {}. Per CONTEXT: avoid throws for valid inputs; use standard practice for pivot selection.

Reference 07-RESEARCH.md for algorithm detail and pseudocode. SPEC requires M as rows; all rows same length (caller responsibility).
  </action>
  <verify>Compile: g++ -std=c++20 -O2 -o qseries src/main.cpp (after Task 2 adds include; or compile a minimal test that includes linalg.h and frac.h).</verify>
  <done>kernel(M) exists and returns basis; gauss_to_rref produces correct RREF; edge cases return {} or canonical basis as specified.</done>
</task>

<task type="auto">
  <name>Task 2: Add main.cpp tests for kernel</name>
  <files>src/main.cpp</files>
  <action>
Add a new test group "linalg kernel" to main.cpp:

1. **Include:** `#include "linalg.h"` near other includes.

2. **Helper:** matrix-vector product for verification — given M (rows) and v (length ncols), compute M*v and check all components are 0. Use Frac arithmetic.

3. **Tests:**
   - 2×3 one relation: M = [[1,1,0],[2,2,0]] → kernel has 2 vectors; for each v, verify M*v = 0.
   - Full rank: M = [[1,0],[0,1]] → kernel is empty {}.
   - All-zero 2×3: M = [[0,0,0],[0,0,0]] → kernel has 3 vectors = canonical basis; verify M*v = 0.
   - Single row: M = [[1,2,3]] → kernel has 2 vectors (one pivot, two free); verify M*v = 0.

4. Use existing CHECK(cond) macro. Add CHECK(basis.size() == expected) and CHECK(Mv_is_zero(M, v)) for each returned v.
  </action>
  <verify>g++ -std=c++20 -O2 -o qseries src/main.cpp 2>&1; ./qseries 2>&1 | grep -E "linalg|PASS|FAIL" — all linalg tests PASS.</verify>
  <done>Four test cases pass; each kernel vector v satisfies M*v = 0.</done>
</task>

</tasks>

<verification>
- Build succeeds with no warnings.
- All linalg kernel tests PASS.
- For 2×3 [[1,1,0],[2,2,0]]: kernel dimension 2, M*v=0 for both vectors.
- For [[1,0],[0,1]]: kernel empty.
- For all-zero 2×3: kernel = 3 canonical basis vectors.
- For [[1,2,3]]: kernel dimension 2, M*v=0.
</verification>

<success_criteria>
- kernel(M) API matches SPEC; returns basis for null space.
- Gaussian elimination (internal) produces correct RREF.
- Edge cases (empty, all-zero, full-rank, single-row) handled per RESEARCH.
- main.cpp linalg tests pass; M*v=0 verified for all returned vectors.
</success_criteria>

<output>
After completion, create `.planning/phases/07-linalg/07-01-SUMMARY.md`
</output>
