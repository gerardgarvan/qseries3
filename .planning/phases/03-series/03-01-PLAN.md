---
phase: 03-series
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/series.h]
autonomous: true

must_haves:
  truths:
    - "(1-q) * (1/(1-q)) = 1 to truncation"
    - "Inverse recurrence uses j=1..n (not j=0); invert q*(1-q) correctly"
    - "Truncation propagates: result.trunc = min(a.trunc, b.trunc) for binary ops"
    - "Multiplication skips pairs where e1+e2 >= trunc"
    - "Throw on invalid inverse (c₀=0, zero series)"
  artifacts:
    - path: src/series.h
      provides: Series struct, arithmetic, inverse, subs_q, str
      contains: "struct Series"
  key_links:
    - from: "Series"
      to: "frac.h"
      via: "#include frac.h, std::map<int,Frac>"
      pattern: "Frac"
---

<objective>
Implement src/series.h with truncated formal power series. Per SPEC and CONTEXT: std::map<int,Frac> c, int trunc; +, -, *, /, pow, inverse; subs_q; truncation propagation; inverse recurrence j=1..n; mult skip e1+e2>=trunc.
</objective>

Purpose: Foundation for qfuncs (Phase 4). Series must have correct inverse (PITFALLS #1) and truncation propagation (PITFALLS #4). Must pass (1-q)*(1/(1-q))=1 before Phase 4.
Output: src/series.h with full Series API.

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-series/03-CONTEXT.md
@.planning/research/PITFALLS.md
@SPEC.md
@.cursorrules
@src/frac.h
@src/bigint.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Series struct, constructors, coeff access</name>
  <files>src/series.h</files>
  <action>
Create src/series.h (guard: SERIES_H). Include "frac.h".

1. **struct Series** with `std::map<int, Frac> c` and `int trunc`. Per .cursorrules: struct with methods.

2. **Constructors / factories**:
   - `static Series zero(int T)` — empty map, trunc=T
   - `static Series one(int T)` — c[0]=1, trunc=T
   - `static Series q(int T)` — c[1]=1, trunc=T
   - `static Series qpow(int e, int T)` — c[e]=1, trunc=T (e in [0..T-1])
   - `static Series constant(Frac f, int T)` — c[0]=f (if nonzero), trunc=T

3. **Coefficient access**: `Frac coeff(int n) const` (return 0 for missing), `void setCoeff(int n, Frac v)`, `int minExp() const`, `int maxExp() const`.

4. **Truncation**: `void clean()` — remove zeros and terms with exponent >= trunc; `Series truncTo(int T) const`.
</action>
  <verify>Series::one(10).coeff(0)==Frac(1); Series::q(10).coeff(1)==Frac(1); minExp/maxExp correct</verify>
  <done>Struct and factories work; coeff access and clean/truncTo implemented</done>
</task>

<task type="auto">
  <name>Task 2: Arithmetic +, -, *, scalar; truncation propagation</name>
  <files>src/series.h</files>
  <action>
Add arithmetic with **truncation propagation** (PITFALLS #4): result.trunc = min(a.trunc, b.trunc).

1. **operator-()** — negate coefficients, keep trunc
2. **operator+** — add coefficients, result.trunc = min(a.trunc, b.trunc)
3. **operator-** — subtract, result.trunc = min(a.trunc, b.trunc)
4. **operator*(const Series&)** — double loop over both maps; for each (e1,c1) and (e2,c2):
   - **Skip if e1+e2 >= min(a.trunc, b.trunc)** (PITFALLS: mult trunc skip)
   - accumulate c1*c2 at exponent e1+e2
   - result.trunc = min(a.trunc, b.trunc)
5. **operator*(const Frac&)** — scale coefficients, trunc unchanged

Use std::map iteration (ordered). Ensure all binary ops set result.trunc = min(trunc_a, trunc_b).
</action>
  <verify>(1-q)*(1+q) gives 1-q²; trunc propagates; mult skips e1+e2>=trunc</verify>
  <done>+, -, *, scalar* implemented with truncation and mult skip</done>
</task>

<task type="auto">
  <name>Task 3: inverse(), operator/, pow</name>
  <files>src/series.h</files>
  <action>
Add inverse, division, pow. **PITFALLS #1: j MUST start at 1.**

1. **inverse()**: If c₀=0 (or minExp>0), **throw std::invalid_argument** (per CONTEXT).
   - If minExp()>0: form h = f/q^m (shift exponents -m), invert h, return result with exponents shifted back by -m. Effective trunc = trunc - m.
   - Recurrence: g[0]=1/c₀; for n≥1: g[n] = -(1/c₀) * Σ_{j=1}^{n} c[j]*g[n-j]. **j from 1 to n, NOT 0.**
   - Add comment: // j MUST start at 1 — j=0 would include c₀*g[n] (circular)
   - Result trunc = this->trunc (or effective trunc for shifted case)

2. **operator/**: a / b = a * b.inverse(). Throw if b not invertible (match inverse).

3. **pow(int n)**: For n>0 use binary exponentiation. For n<0: inverse().pow(-n). For n==0: return one(trunc).
</action>
  <verify>(1-q)*((Series::one(20)-Series::q(20)).inverse()) == Series::one(20); q*(1-q) invertible</verify>
  <done>inverse with j=1..n; division; pow; shift for minExp>0</done>
</task>

<task type="auto">
  <name>Task 4: subs_q, str, display</name>
  <files>src/series.h</files>
  <action>
Add subs_q and display.

1. **subs_q(int k)**: f(q) → f(q^k). Multiply each exponent by k. result.trunc = trunc * k (PITFALLS: subs_q trunc).
   - subs_q(0): return constant series (collapse all terms to constant) — per CONTEXT
   - k<0: implementation choice (suggest: allow, trunc becomes trunc*|k|; exponents scaled)
   - subs_q(1): return copy (or no-op)

2. **str(int maxTerms=30)**: Per CONTEXT: "1 + q + 2q² + 3q³ + O(q^T)". Constant term as "1" (omit *q^0). Use Unicode exponents ⁰¹²³⁴⁵⁶⁷⁸⁹. When maxTerms reached: " + O(q^T)". Negative coeffs: use " - " or "-" as needed.

3. **display(int maxTerms=40)**: std::cout << str(maxTerms) << std::endl;

4. **coeffList(int from, int to)**: return vector of Frac for exponents from..to (inclusive).
</action>
  <verify>subs_q(2) on 1+q+q² gives 1+q²+q⁴; str() format matches spec</verify>
  <done>subs_q, str, display, coeffList implemented</done>
</task>

</tasks>

<verification>
- g++ -std=c++20 -O2 -o qseries src/main.cpp compiles (with #include "series.h" added in 03-02)
- (1-q) * (1/(1-q)) = 1 to truncation (Plan 03-02 will add explicit test)
- inverse of q*(1-q) works
- Multiplication skips e1+e2>=trunc; truncation propagates in all binary ops
</verification>

<success_criteria>
- series.h provides full Series API per SPEC
- Inverse recurrence j=1..n; invalid inverse throws
- Truncation min(Ta,Tb) in binary ops; mult skip; subs_q trunc = f.trunc * k
- Ready for Plan 03-02 (test driver)
</success_criteria>

<output>
After completion, create `.planning/phases/03-series/03-01-SUMMARY.md`
</output>
