---
phase: 03-series
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified: [src/main.cpp]
autonomous: true

must_haves:
  truths:
    - "(1-q)*(1/(1-q))=1 to truncation"
    - "add/sub/mul/div, subs_q, pow, inverse edge cases pass"
    - "Series tests must pass before Phase 4 (qfuncs)"
  artifacts:
    - path: src/main.cpp
      provides: BigInt + Frac + Series test driver
      contains: "Series"
  key_links:
    - from: "main.cpp"
      to: "series.h"
      via: "#include"
      pattern: "#include.*series"
---

<objective>
Extend src/main.cpp with Series test suite. Per CONTEXT: broader suite (SPEC cases + add/sub/mul/div + subs_q + pow + inverse edge cases). Must pass before Phase 4.
</objective>

Purpose: Validate Series implementation. Locked decision: both standalone (this) and integration (Phase 4) tests; must pass before Phase 4.
Output: main.cpp runs BigInt, Frac, and Series tests; exits 0 when all pass.

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-series/03-CONTEXT.md
@.planning/phases/03-series/03-01-PLAN.md
@.planning/research/PITFALLS.md
@SPEC.md
@src/main.cpp
@src/series.h
@src/frac.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Series include and SPEC cases</name>
  <files>src/main.cpp</files>
  <action>
Add #include "series.h" after frac.h. Keep existing BigInt and Frac tests. Add new section "=== Series Phase 3 test driver ===".

Add Series test groups using the same CHECK macro:

1. **SPEC: (1-q)*(1/(1-q))=1** (PITFALLS verification):
   - auto one_q = Series::one(20) - Series::q(20);
   - auto inv = one_q.inverse();
   - CHECK((one_q * inv).coeff(0) == Frac(1));
   - CHECK((one_q * inv).coeff(1) == Frac(0)); // ... verify up to trunc-1

2. **Inverse with minExp>0**: invert q*(1-q):
   - auto f = Series::q(20) * (Series::one(20) - Series::q(20));
   - auto g = f.inverse(); CHECK g is q^{-1}*(1-q)^{-1} = 1/(q*(1-q))
   - Spot-check coefficients

3. **Invalid inverse throws**:
   - try { Series::zero(10).inverse(); } catch (std::invalid_argument&) { threw = true; }
   - try { Series::q(10).inverse(); } catch ... (c₀=0)
</action>
  <verify>(1-q)*(1/(1-q))=1; q*(1-q) invertible; zero/q inverse throws</verify>
  <done>SPEC inverse tests pass</done>
</task>

<task type="auto">
  <name>Task 2: add/sub/mul/div, truncation, mult skip</name>
  <files>src/main.cpp</files>
  <action>
Add Series arithmetic and truncation tests:

1. **add/sub**:
   - (1+q) + (1-q) == 2
   - (1+q+q²) - (1) == q+q²
   - truncation: (1+q) with T=5 + (1+q) with T=3 → result.trunc==3

2. **mul**:
   - (1-q)*(1+q) == 1-q²
   - (1+q)*(1+q) == 1+2q+q²
   - truncation propagates: result.trunc = min(Ta,Tb)

3. **div**:
   - (1-q²) / (1-q) == 1+q
   - division by non-invertible throws (if that's the decision)

4. **Truncation and mult skip**: Verify no terms beyond trunc; mult skips e1+e2>=trunc (implicit via correctness)
</action>
  <verify>All add/sub/mul/div CHECKs pass; truncation correct</verify>
  <done>Arithmetic tests pass</done>
</task>

<task type="auto">
  <name>Task 3: subs_q, pow, str</name>
  <files>src/main.cpp</files>
  <action>
Add subs_q, pow, and str tests:

1. **subs_q**:
   - (1+q+q²).subs_q(2) == 1+q²+q⁴
   - subs_q(0): (1+q+q²).subs_q(0) → constant (sum of coeffs)
   - truncation: result.trunc == f.trunc * k

2. **pow**:
   - (1+q).pow(2) == 1+2q+q²
   - (1+q).pow(0) == 1
   - (1/(1-q)).pow(-1) == (1-q) (inverse of inverse)

3. **str**:
   - Series::one(5).str() contains "1" and "O(q^"
   - Series::q(5).str() contains "q"
   - Format: "1 + q + 2q² + ..." style
</action>
  <verify>subs_q, pow, str tests pass</verify>
  <done>subs_q, pow, str tests pass; Phase 3 success criteria satisfied</done>
</task>

</tasks>

<verification>
- g++ -std=c++20 -O2 -static -o qseries src/main.cpp succeeds
- ./qseries exits 0
- All BigInt and Frac tests still pass
- All Series tests pass (SPEC inverse + arithmetic + subs_q + pow + str)
</verification>

<success_criteria>
- Phase 3 success criteria met: (1-q)*(1/(1-q))=1; inverse j=1..n; truncation propagation; mult skip
- Test suite covers SPEC cases, add/sub/mul/div, subs_q, pow, inverse edge cases
- Ready for Phase 4 (qfuncs)
</success_criteria>

<output>
After completion, create `.planning/phases/03-series/03-02-SUMMARY.md`
</output>
