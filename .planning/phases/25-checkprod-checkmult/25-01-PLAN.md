---
phase: 25-checkprod-checkmult
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/convert.h
  - src/repl.h
  - tests/acceptance-checkprod-checkmult.sh
autonomous: true

must_haves:
  truths:
    - "checkprod(Rogers-Ramanujan sum, 20) returns nice product (minExp=0)"
    - "checkprod with non-nice product returns not a nice product and minExp"
    - "checkmult on multiplicative series returns MULTIPLICATIVE"
    - "checkmult on non-multiplicative series returns NOT MULTIPLICATIVE"
  artifacts:
    - path: src/convert.h
      provides: checkprod(f,M,T), checkprod(f,T), checkmult(f,T), checkmult(f,T,verbose)
      contains: "checkprod"
    - path: src/repl.h
      provides: CheckprodResult, CheckmultResult, format, display, dispatch, help
      contains: "checkprod"
  key_links:
    - from: src/repl.h dispatch
      to: src/convert.h checkprod/checkmult
      via: checkprod(ev(0), evi(1)) or checkprod(ev(0), evi(1), evi(2))
      pattern: "checkprod\\(ev|checkmult\\(ev"
---

<objective>
Implement checkprod and checkmult: validation utilities for q-series. checkprod verifies f is a "nice" product (all |a[n]| &lt; M); checkmult verifies coefficients are multiplicative.

Purpose: Close GAP-02 and GAP-03 from FEATURE-GAPS; enable Maple-style validation of product form and multiplicativity.

Output: checkprod, checkmult in convert.h; REPL dispatch, display, help in repl.h; acceptance test script.
</objective>

<execution_context>
Execute with fresh context. Build: g++ -std=c++20 -O2 -static -o qseries main.cpp (or make).
</execution_context>

<context>
@.planning/phases/25-checkprod-checkmult/25-RESEARCH.md
@.planning/phases/25-checkprod-checkmult/25-CONTEXT.md
@src/convert.h
@src/repl.h
@src/series.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement checkprod and checkmult in convert.h</name>
  <files>src/convert.h</files>
  <action>
Add after mprodmake (around line 164), before T_rn.

Define result structs in convert.h:
- struct CheckprodResult { int minExp; bool nice; int M; };
- struct CheckmultResult { bool multiplicative; std::vector&lt;std::pair&lt;int,int&gt;&gt; failures; };

**checkprod** — two overloads:

1. `checkprod(f, T)` — M=2 (default "nice" = exponents in {-1,0,1}).
   Return struct: `struct CheckprodResult { int minExp; bool nice; int M; };`
   Algorithm: g = f.truncTo(T); if g.coeff(0).isZero() or g.minExp() &gt; 0, set minExp from g.minExp(), nice=false, M=2, return. Otherwise: a = prodmake(g, T); if a.empty() return {minExp, false, 2}. minExp = g.minExp(). For n=1..T-1: get |a[n]| as int (same pattern as mprodmake for Frac-&gt;int); if any |a[n]| &gt;= M, return {minExp, false, M}. Else return {minExp, true, M}.

2. `checkprod(f, M, T)` — explicit M.
   Same logic with provided M.

**checkmult** — `struct CheckmultResult { bool multiplicative; std::vector&lt;std::pair&lt;int,int&gt;&gt; failures; };`

Signature: `CheckmultResult checkmult(const Series&amp; f, int T, bool verbose = false)`

Algorithm: g = f.truncTo(T). For m from 2 to sqrt(T) (or T-1), for n from 2 to T/m (so m*n &lt; T), if gcd(m,n)==1: a_mn = g.coeff(m*n), a_m = g.coeff(m), a_n = g.coeff(n); if a_mn != a_m * a_n, record (m,n) in failures, set multiplicative=false. Use simple int gcd: `auto gcd_int = [](int a, int b){ a=(a&lt;0)?-a:a; b=(b&lt;0)?-b:b; while(b){int t=b; b=a%b; a=t;} return a; };` coprime = gcd_int(m,n)==1. Iterate m=2..T-1, n=2..T-1, m*n&lt;T, gcd(m,n)==1. If verbose, collect all failures; else return on first failure. Return {all pass, failures}.
  </action>
  <verify>Build succeeds. Manual: checkprod(etaq(1,50), 20) in REPL; checkmult(etaq(1,50), 50).</verify>
  <done>checkprod and checkmult exist in convert.h; return correct result structs.</done>
</task>

<task type="auto">
  <name>Task 2: EvalResult types, format, display, dispatch, help in repl.h</name>
  <files>src/repl.h</files>
  <action>
1. Add to EvalResult variant (after std::vector&lt;int&gt;, ~line 127): CheckprodResult, CheckmultResult. Forward-declare or include convert.h (repl already includes convert.h; add CheckprodResult and CheckmultResult to convert.h and use them here).

2. Add formatCheckprod(CheckprodResult r): if r.nice return "nice product (minExp=" + std::to_string(r.minExp) + ")"; else return "not a nice product (bound M=" + std::to_string(r.M) + "), minExp=" + std::to_string(r.minExp).

3. Add formatCheckmult(CheckmultResult r): if r.multiplicative return "MULTIPLICATIVE"; else { s = "NOT MULTIPLICATIVE"; for (auto [m,n] : r.failures) s += " (m=" + std::to_string(m) + ",n=" + std::to_string(n) + ")"; return s; }

4. In display() visitor: add cases for CheckprodResult and CheckmultResult calling the formatters.

5. In dispatchBuiltin: checkprod — args.size()==2: return checkprod(ev(0), static_cast&lt;int&gt;(evi(1))); args.size()==3: return checkprod(ev(0), static_cast&lt;int&gt;(evi(1)), static_cast&lt;int&gt;(evi(2))); else throw. checkmult — args.size()==2: return checkmult(ev(0), static_cast&lt;int&gt;(evi(1)), false); args.size()==3: return checkmult(ev(0), static_cast&lt;int&gt;(evi(1)), evi(2)!=0); else throw.

6. In getHelpTable(): {"checkprod", {"checkprod(f,T) or checkprod(f,M,T)", "check if f is a nice product (exponents |a[n]| &lt; M)"}}, {"checkmult", {"checkmult(f,T) or checkmult(f,T,1)", "check if coefficients are multiplicative"}}
  </action>
  <verify>Build succeeds. REPL: checkprod(etaq(1,50), 20) prints "nice product (minExp=0)". checkprod with Rogers-Ramanujan sum up to q^20 prints "nice product". checkmult(etaq(1,50), 50) prints "MULTIPLICATIVE". help(checkprod) and help(checkmult) work.</verify>
  <done>checkprod and checkmult built-ins work; display shows correct messages; help entries exist.</done>
</task>

<task type="auto">
  <name>Task 3: Acceptance test for checkprod and checkmult</name>
  <files>tests/acceptance-checkprod-checkmult.sh</files>
  <action>
Create tests/acceptance-checkprod-checkmult.sh:

1. Same BIN resolution as acceptance-wins.sh: dist/qseries.exe, dist/qseries, qseries.exe, qseries.

2. run() helper: printf inputs | "$BIN" 2&gt;&amp;1

3. Test 1 — checkprod nice: rr := sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8); checkprod(rr, 20). Expect output containing "nice product" and "minExp=0" (Rogers-Ramanujan is nice within T=20 with M=2).

4. Test 2 — checkmult multiplicative: etaq(1,50) has multiplicative coefficients (Euler). Run checkmult(etaq(1,50), 50). Expect "MULTIPLICATIVE".

5. Test 3 — checkmult non-multiplicative: F1 = sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8) (Rogers-Ramanujan G). F1 is NOT multiplicative. checkmult(F1, 30). Expect "NOT MULTIPLICATIVE".

6. Make script executable (chmod +x) and run it.
  </action>
  <verify>./tests/acceptance-checkprod-checkmult.sh exits 0; all tests pass.</verify>
  <done>Acceptance test passes; checkprod and checkmult behave per Maple semantics.</done>
</task>

</tasks>

<verification>
- Build: make dist/qseries.exe or g++ -std=c++20 -O2 -o qseries main.cpp
- Rogers-Ramanujan: rr := sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8); checkprod(rr, 20) → "nice product (minExp=0)"
- etaq(1,50) multiplicative: checkmult(etaq(1,50), 50) → "MULTIPLICATIVE"
- Rogers-Ramanujan G not multiplicative: checkmult(rr, 30) → "NOT MULTIPLICATIVE"
</verification>

<success_criteria>
- checkprod(f,T) and checkprod(f,M,T) work; return nice/not nice with minExp
- checkmult(f,T) and checkmult(f,T,1) work; return MULTIPLICATIVE / NOT MULTIPLICATIVE
- Display shows correct messages per CONTEXT
- help(checkprod) and help(checkmult) show signatures and descriptions
- tests/acceptance-checkprod-checkmult.sh exits 0
</success_criteria>

<output>
After completion, create .planning/phases/25-checkprod-checkmult/25-01-SUMMARY.md
</output>
