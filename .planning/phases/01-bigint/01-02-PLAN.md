---
phase: 01-bigint
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified: [src/bigint.h]
autonomous: true

must_haves:
  truths:
    - "Long division uses binary-search quotient; remainder invariant 0 ≤ r < |b| holds"
    - "divmod returns correct (q,r) for a = q*b + r"
    - "GCD computes correctly; edge cases (0, negatives, base boundaries) handled"
  artifacts:
    - path: src/bigint.h
      provides: divmod, operator/, operator%, bigGcd
      contains: "divmod"
  key_links:
    - from: "BigInt::divmod"
      to: "binary-search quotient digit"
      via: "find largest k in [0,BASE-1] s.t. k*divisor ≤ remainder"
      pattern: "lo|hi|mid|binary"
    - from: "bigGcd"
      to: "divmod"
      via: "Euclidean loop: a,b = b, a%b"
      pattern: "divmod|while.*!b.isZero"
---

<objective>
Implement BigInt divmod (binary-search quotient), operator/, operator%, and bigGcd. Validate divisor before division — throw on zero.
</objective>

Purpose: Division is the hardest BigInt operation (RESEARCH, SPEC). Binary-search quotient avoids quotient-digit overshoot at base boundaries. Required for Frac and GCD.
Output: Complete BigInt API in src/bigint.h.

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bigint/01-RESEARCH.md
@.planning/phases/01-bigint/01-CONTEXT.md
@SPEC.md
@src/bigint.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: divmod with binary-search quotient</name>
  <files>src/bigint.h</files>
  <action>
Implement static std::pair&lt;BigInt,BigInt&gt; divmod(const BigInt&amp; a, const BigInt&amp; b):

1. **Validation**: If b.isZero(), throw std::invalid_argument (or domain_error — CONTEXT: Claude's discretion). Per CONTEXT: validate divisor before division, throw if zero.

2. **Sign handling**: Compute divmod(|a|, |b|) on absolutes. Then: q_neg = (a.neg != b.neg), r_neg = a.neg. Standard: a = q*b + r with 0 ≤ r &lt; |b|.

3. **Long division**: Divisor has n_d digits. For each quotient digit:
   - Use n_d+1 digits of current remainder (or normalized equivalent) — per janmr/Knuth Algorithm D
   - Binary search: find largest k in [0, BASE-1] such that k * divisor ≤ remainder
   - Subtract k*divisor from remainder; append k to quotient
   - Normalize remainder (no leading zeros)

4. **Binary search loop** (from RESEARCH):
   uint32_t lo=0, hi=BASE-1;
   while (lo &lt; hi) {
     uint32_t mid = lo + (hi - lo + 1) / 2;
     BigInt prod = divisor * BigInt(mid);
     if (cmpAbs(prod, remainder) &lt;= 0) lo = mid;
     else hi = mid - 1;
   }
   Ensure remainder and divisor are normalized before each step.

5. **Critical test cases** (SPEC): 1000000000/1, 999999999/1000000000, 123456789012345/123. These exercise base-boundary quotient digit selection.
</action>
  <verify>Run: BigInt("1000000000")/BigInt("1") == BigInt("1000000000"); BigInt("999999999")/BigInt("1000000000") == BigInt("0") with remainder 999999999; BigInt("123456789012345")/BigInt("123") has correct quotient</verify>
  <done>divmod satisfies a == q*b + r and 0 ≤ r &lt; |b|; binary-search used; base-boundary cases pass</done>
</task>

<task type="auto">
  <name>Task 2: operator/, operator%, bigGcd</name>
  <files>src/bigint.h</files>
  <action>
Add to bigint.h:

1. **operator/**: Return divmod(a,b).first. Throws if b is zero (divmod validates).

2. **operator%**: Return divmod(a,b).second. Same validation.

3. **bigGcd(BigInt a, BigInt b)**: Free function (not member). Euclidean algorithm:
   - a = |a|, b = |b|
   - while (!b.isZero()) { auto [q,r] = divmod(a,b); a = std::move(b); b = std::move(r); }
   - return a
   - gcd(0,x) = |x|, gcd(x,0) = |x|

4. **Edge cases**: gcd with negative args (use abs); gcd(0, n) = |n|; gcd(n, 0) = |n|.
</action>
  <verify>bigGcd(BigInt(48), BigInt(18)) == 6; bigGcd(BigInt(0), BigInt(7)) == 7; bigGcd(BigInt(-12), BigInt(8)) == 4</verify>
  <done>/, % delegate to divmod; bigGcd produces correct results for edge cases</done>
</task>

</tasks>

<verification>
- divmod passes SPEC division cases: 1000000000/1, 999999999/1000000000, 123456789012345/123
- Remainder invariant holds: 0 ≤ r &lt; |b|
- bigGcd(48,18)==6; division by zero throws
</verification>

<success_criteria>
- CORE-02 satisfied: divmod with binary-search quotient, GCD via divmod
- All SPEC division edge cases produce correct quotient and remainder
</success_criteria>

<output>
After completion, create `.planning/phases/01-bigint/01-02-SUMMARY.md`
</output>
