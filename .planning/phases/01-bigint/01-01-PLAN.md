---
phase: 01-bigint
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/bigint.h]
autonomous: true

must_haves:
  truths:
    - "BigInt supports +, -, * with correct results for large operands"
    - "BigInt comparisons work correctly"
    - "Zero is always non-negative; 0*anything=0, (-a)*(-b)=a*b"
  artifacts:
    - path: src/bigint.h
      provides: BigInt struct with constructors, comparisons, add, sub, mul, str
      contains: "struct BigInt"
  key_links:
    - from: "BigInt::operator*"
      to: "uint64_t for digit products"
      via: "use 1ULL * a[i] * b[j] to avoid overflow"
      pattern: "uint64_t|1ULL"
---

<objective>
Implement BigInt core: struct, constructors, comparisons, addition, subtraction, multiplication, and string I/O. No divmod yet — that is Plan 02.
</objective>

Purpose: Foundation for exact arithmetic. Frac and Series depend on BigInt. Must be correct before divmod.
Output: src/bigint.h with full add/sub/mul, comparisons, str(), string constructor.

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-bigint/01-RESEARCH.md
@.planning/phases/01-bigint/01-CONTEXT.md
@SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: BigInt struct, constructors, comparisons, str</name>
  <files>src/bigint.h</files>
  <action>
Create src/bigint.h (create src/ if missing). Implement:

1. **Struct**: `bool neg`, `std::vector&lt;uint32_t&gt; d` (least-significant first), BASE = 1000000000.

2. **Constructors**:
   - `BigInt()` — zero: neg=false, d={0} (canonical zero per RESEARCH)
   - `BigInt(int64_t v)` — from machine integer; handle negative
   - `BigInt(const std::string&amp; s)` — parse decimal; strip leading whitespace per CONTEXT (Claude's discretion); reject invalid chars — throw std::invalid_argument
   - Trim leading zeros after parse (except single "0")

3. **Helpers**: `isZero()`, `abs()`, `normalize()` — remove leading zeros; zero is always neg=false

4. **Comparisons**: `cmpAbs(a,b)` static; `operator==`, `!=`, `&lt;`, `&gt;`, `&lt;=`, `&gt;=` — signed comparison

5. **str()**: Decimal output; most-significant first; pad lower digits to 9 chars; prepend "-" if neg. Zero outputs "0".

Follow RESEARCH: cp-algorithms patterns, explicit neg flag, no two's complement in limbs.
</action>
  <verify>Create minimal test file including bigint.h; instantiate BigInt("0"), BigInt(-42); verify str() outputs; g++ -std=c++20 -O2 compiles without error</verify>
  <done>BigInt("0").str()=="0"; BigInt("-42").str()=="-42"; BigInt(123456789).str()=="123456789"; comparisons compile</done>
</task>

<task type="auto">
  <name>Task 2: Addition, subtraction, multiplication</name>
  <files>src/bigint.h</files>
  <action>
Add to bigint.h:

1. **Unsigned helpers** (internal, static or private): `addAbs(a,b)` returns |a|+|b|; `subAbs(a,b)` requires |a|&gt;=|b|, returns |a|-|b|. Use uint64_t for carry. Normalize result.

2. **operator+**: Route by sign — same sign → addAbs; opposite → subAbs (larger minus smaller, sign = sign of larger). Zero + x = x.

3. **operator-**: a - b = a + (-b). Unary `operator-()`: flip neg if !isZero().

4. **operator***: Schoolbook O(n·m). For each digit pair, use `cur = a[i] * 1ULL * b[j]` (uint64_t) to avoid overflow. Accumulate into result vector with carry. Handle signs: result.neg = a.neg != b.neg; zero * anything = 0.

5. **operator* edge cases**: 0*anything=0; (-a)*(-b)=a*b (per SPEC/.cursorrules).

Reference RESEARCH code examples for add/sub/mul loops.
</action>
  <verify>Compile a minimal main that does BigInt("999999999")*BigInt("999999999") and prints result; no overflow</verify>
  <done>Add/sub/mul produce correct results; (-7)*(-3)==21; 0*x==0</done>
</task>

</tasks>

<verification>
- src/bigint.h exists and compiles with g++ -std=c++20
- No divmod, /, %, or bigGcd in this plan — those are Plan 02
</verification>

<success_criteria>
- BigInt supports +, -, * with correct signed arithmetic
- Zero normalized; comparisons work; str() and string ctor work
- Throws on invalid string input
</success_criteria>

<output>
After completion, create `.planning/phases/01-bigint/01-01-SUMMARY.md`
</output>
