---
phase: 10-repl
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/repl.h
  - src/main.cpp
autonomous: true

must_haves:
  truths:
    - "repl.h exists with Env, EvalResult, evalToInt, eval, display helpers"
    - "runRepl() reads lines, parses, evaluates, displays; REPL continues after errors"
    - "Prompt is exactly 'qseries> '; banner shows ASCII kangaroo and version 1.0"
  artifacts:
    - path: src/repl.h
      provides: REPL infrastructure and evaluation engine
      contains: "runRepl", "eval", "evalToInt", "EvalResult"
    - path: src/main.cpp
      provides: Entry point with REPL invocation
      contains: "runRepl"
  key_links:
    - from: src/repl.h
      to: src/parser.h
      via: "parse(), Stmt, Expr"
      pattern: "parse|Stmt|Expr"
    - from: src/repl.h
      to: src/series.h
      via: Series arithmetic and str()
      pattern: "Series::"
    - from: src/main.cpp
      to: src/repl.h
      via: "#include and runRepl()"
      pattern: "runRepl"
---

<objective>
Create repl.h with variable environment, eval engine (evalToInt + eval), EvalResult variant, display helpers (formatProdmake, formatEtamake, formatQfactor, formatRelation), and runRepl loop with std::getline, history 100, prompt "qseries> ", ASCII kangaroo banner. main.cpp calls runRepl() for interactive mode.

Purpose: Foundation for built-in dispatch; user can parse and evaluate basic expressions (q, vars, literals, arithmetic) and see formatted output.
Output: src/repl.h, src/main.cpp wired to REPL
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-repl/10-CONTEXT.md
@.planning/phases/10-repl/10-RESEARCH.md
@src/parser.h
@src/series.h
@src/frac.h
@src/convert.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Env, EvalResult, evalToInt, eval (core expressions)</name>
  <files>src/repl.h</files>
  <action>
Create src/repl.h with:

1. **EnvValue** — std::variant&lt;Series, std::vector&lt;JacFactor&gt;&gt;. Include convert.h for JacFactor.

2. **Environment** — std::map&lt;std::string, EnvValue&gt; env; int T (default 50). Pre-populate env["q"] = Series::q(T).

3. **EvalResult** — std::variant over: Series, std::map&lt;int,Frac&gt; (prodmake), std::vector&lt;std::pair&lt;int,Frac&gt;&gt; (etamake), std::vector&lt;JacFactor&gt; (jacprodmake), std::vector&lt;std::vector&lt;Frac&gt;&gt; (findhom/findnonhom), std::optional&lt;std::vector&lt;Frac&gt;&gt; (findhomcombo/findnonhomcombo), QFactorResult (qfactor), int64_t (legendre/sigma), DisplayOnly (tag for series/coeffs), std::monostate (set_trunc). Use struct wrappers if needed for clarity.

4. **evalToInt(Expr*, env, sumIndices) → int64_t** — Handles IntLit (return intVal), Var (if in sumIndices return value; else throw "expected integer"). BinOp(Add/Sub/Mul/Pow) on integer subexprs: recurse, compute. Throw on non-integer (e.g. Var not in sumIndices).

5. **eval(Expr*, env, sumIndices) → EvalResult** — Handles: IntLit → throw or return constant 0 (IntLit is for args only); Q → env["q"]; Var → env[name] (throw if missing); for Var in sumIndices return Series::constant(Frac(n), T) so q^n works in sum body; BinOp(Add,Sub,Mul,Div) → eval both sides, apply Series ops; BinOp(Pow, left, right): if left is Q (or Q-like), use evalToInt(right) and return Series::qpow(expVal, T); else Series.pow(); UnOp → -eval(operand). Call stub returns DisplayOnly for unknown (we add built-ins in 10-02).

6. **sumIndices** — std::map&lt;std::string, int64_t&gt; passed through eval; empty for top-level.
</action>
  <verify>Build: make -C project_root qseries.exe (or g++ -std=c++20 -O2 -o qseries src/main.cpp with -I. from project root). No linker errors for repl.h symbols.</verify>
  <done>evalToInt and eval compile; eval(Q) returns env["q"]; eval(BinOp(Add,q,q)) returns Series; BinOp(Pow,Q,IntLit(2)) returns q².</done>
</task>

<task type="auto">
  <name>Task 2: Display helpers (formatProdmake, formatEtamake, formatQfactor, formatRelation)</name>
  <files>src/repl.h</files>
  <action>
Add to repl.h (inline functions):

1. **formatProdmake(const std::map&lt;int,Frac&gt;&amp; a) → std::string** — Per qseriesdoc: numerator = product over n where a[n] &lt; 0 of (1-q^n)^{-a[n]}; denominator = product over n where a[n] &gt; 0. Output "1 / ((1-q)(1-q^4)...)" style. Use Series::expToUnicode for exponents.

2. **formatEtamake(const std::vector&lt;std::pair&lt;int,Frac&gt;&gt;&amp;) → std::string** — Per qseriesdoc: η(kτ)^{e_k}. Output "η(2τ)⁵ / (η(4τ)² η(τ)²)" style. Numerator: positive e; denominator: negative e. Use Unicode η, ², ⁵ etc.

3. **formatQfactor(const QFactorResult&amp;) → std::string** — Per SPEC Test 7: "q⁶·(1-q⁹)(1-q¹⁰)... / ((1-q)(1-q²)...)". Use jac2prod-style exponent formatting.

4. **formatRelation(const std::vector&lt;Frac&gt;&amp; coeffs, monomialExponents, varNames) → std::string** — Format kernel vector as "X₁²+X₂²-2X₃²". Default varNames = {"X₁","X₂",...}. Monomials from relations.h enumerate order.

5. **display(EvalResult, env, T)** — Switch on result type: Series → s.str(30); prodmake → formatProdmake; etamake → formatEtamake; jacprodmake → jac2prod(vec); etc. Print to std::cout.
</action>
  <verify>Call formatProdmake, formatEtamake on sample data; output matches Garvan style (no compile/link needed for helpers alone if eval still stub).</verify>
  <done>All four format helpers exist and produce Garvan-style strings; display() handles each EvalResult variant.</done>
</task>

<task type="auto">
  <name>Task 3: runRepl loop, banner, main.cpp wiring</name>
  <files>src/repl.h, src/main.cpp</files>
  <action>
1. **runRepl()** in repl.h:
   - Print banner: ASCII kangaroo (simple art, ~5 lines) + "q-series REPL (Maple-like), version 1.0" + short description. Implementation discretion on exact art.
   - History: std::deque&lt;std::string&gt; or vector, max 100 entries. On non-empty input: push to history (circular evict oldest).
   - Loop: std::cout &lt;&lt; "qseries> " &lt;&lt; std::flush; std::getline(std::cin, line). Trim (or skip empty after trim).
   - Empty line: continue (do nothing). Do not add to history.
   - Parse: try { auto stmt = parse(line); ... }. On parse error: catch, print message (include position if available from exception), continue.
   - Eval: try { auto res = eval(stmt, env); ... }. On eval error: catch, print message, continue.
   - Assign: if Stmt::Assign, env[assignName] = value before display.
   - Display: call display(res). set_trunc produces no output (monostate).
   - Never exit on user input error; always continue to next prompt.

2. **main.cpp** — Add #include "repl.h" at top. Change main to: int main(int argc, char** argv) { if (argc > 1 && std::string(argv[1]) == "--test") { /* run existing Phase 1-9 unit tests, return fail_count */ return runUnitTests(); } runRepl(); return 0; }. Extract current main body into runUnitTests() so "qseries --test" runs the test driver, else REPL runs. REPL reads from std::cin (works with piping for acceptance tests).
</action>
  <verify>Build succeeds. Run ./qseries.exe (or qseries), type "q" + Enter, see Series output. Type "x := q + q^2", "x", see 1+q+q². Empty line does nothing. Invalid input prints error, prompt returns.</verify>
  <done>REPL runs with prompt "qseries> "; banner shows kangaroo and version 1.0; history 100; empty lines skipped; parse/eval errors caught and REPL continues.</done>
</task>

</tasks>

<verification>
- Build: make (or g++ -std=c++20 -O2 -o qseries src/main.cpp) succeeds
- Interactive: run qseries, type "q", "1+q", "x := q^2", "x" — outputs correct Series
- Error recovery: "foo" (unknown var) prints error, next prompt appears
</verification>

<success_criteria>
- repl.h compiles and links
- runRepl() runs with correct prompt and banner
- eval handles Q, Var, BinOp, UnOp, IntLit (in sumIndices)
- display helpers produce Garvan-style output
</success_criteria>

<output>
After completion, create `.planning/phases/10-repl/10-01-SUMMARY.md`
</output>
