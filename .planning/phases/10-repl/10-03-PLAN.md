---
phase: 10-repl
plan: 03
type: execute
wave: 3
depends_on: [10-02]
files_modified:
  - src/repl.h
  - tests/acceptance.sh
  - Makefile
autonomous: true

must_haves:
  truths:
    - "findhom, findnonhom, findhomcombo, findnonhomcombo, findpoly dispatch correctly"
    - "List eval produces vector<Series> for findhom([...])"
    - "All 9 SPEC acceptance tests pass when run through REPL"
  artifacts:
    - path: src/repl.h
      provides: Relation built-ins and list eval
      contains: "findhom", "findnonhom", "findhomcombo", "findnonhomcombo", "findpoly"
    - path: tests/acceptance.sh
      provides: Automated SPEC acceptance test runner
      contains: "9 test sequences"
  key_links:
    - from: src/repl.h
      to: src/relations.h
      via: findhom, findnonhom, findhomcombo, findnonhomcombo, findpoly
      pattern: "findhom|findnonhom|findpoly"
    - from: tests/acceptance.sh
      to: qseries binary
      via: pipe REPL commands
      pattern: "echo.*|.*qseries"
---

<objective>
Implement relation built-ins (findhom, findnonhom, findhomcombo, findnonhomcombo, findpoly), list eval for findhom([...]), legendre/sigma, and create automated acceptance test script that runs all 9 SPEC tests through the REPL.

Purpose: Gauss AGM (Test 5), Watson (Test 8) require relation built-ins. All 9 SPEC tests must pass for phase completion.
Output: Complete built-in set; tests/acceptance.sh; all 9 tests pass
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-repl/10-CONTEXT.md
@.planning/phases/10-repl/10-RESEARCH.md
@SPEC.md
@src/relations.h
@.planning/phases/10-repl/10-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: List eval and relation built-ins</name>
  <files>src/repl.h</files>
  <action>
1. **List eval** — For Expr::Tag::List: eval each element to Series, collect into std::vector&lt;Series&gt;. Used by findhom(L, n, topshift) and findnonhomcombo(f, [T, xi], n_list, ...).

2. **findhom(L, n, topshift)** — Args: (List, int, int). Eval List → vector&lt;Series&gt; L; evalToInt(n), evalToInt(topshift). Call findhom(L, n, topshift). Return vector&lt;vector&lt;Frac&gt;&gt;. display() uses formatRelation for each kernel vector. Per Test 5: findhom([theta3(q,100), theta4(q,100), theta3(q^2,100), theta4(q^2,100)], 2, 0) — theta3(q^2,100) = theta3(q,100).subs_q(2). Ensure list elements eval to Series with subs_q where needed (theta3(q^2,100) is a Call — dispatch theta3 with 2 args, first is q^2; or user writes theta3(q,100).subs_q(2) — parser may not have subs_q as built-in). Per SPEC: theta3(q^2) means theta3 evaluated at q^2. The C++ theta3(q,T) takes q; theta3(q.subs_q(2), T) would give theta3(q^2). So we need theta3 to accept first arg as Series. etaq, theta* already take q as first arg when 2+ args. For theta3(q^2, 100): args = [q^2, 100] — eval q^2 as Series, call theta3(q_squared, 100). Theta functions in qfuncs take (Series q, int T). So theta3(eval(arg0), evalToInt(arg1)) works. For [theta3(q,100), theta4(q,100), theta3(q^2,100), theta4(q^2,100)]: theta3(q^2,100) requires q^2. In REPL, q^2 is BinOp(Pow,Q,2). eval gives Series q². So theta3(q^2, 100) = Call("theta3", [q^2, 100]) → theta3(eval(q^2), 100) = theta3(Series::qpow(2,T), 100). Good.

3. **findnonhom(L, n, topshift)** — Same pattern; return vector&lt;vector&lt;Frac&gt;&gt;.

4. **findhomcombo(f, L, n, topshift, etaopt?)** — f=Series, L=List→vector&lt;Series&gt;, n, topshift ints, etaopt optional bool. Call findhomcombo(f, L, n, topshift, etaopt). Return optional&lt;vector&lt;Frac&gt;&gt;. display() formats as polynomial.

5. **findnonhomcombo(f, L, n_list, topshift, etaopt?)** — n_list is List of ints: [1, 7] for Watson. Eval list elements with evalToInt → vector&lt;int&gt;. Call findnonhomcombo(f, L, n_list, topshift, etaopt).

6. **findpoly(x, y, deg1, deg2, check?)** — eval(x), eval(y) as Series; evalToInt(deg1, deg2); check optional.

7. **legendre(a, p)**, **sigma(n)** or **sigma(n, k)** — evalToInt args. Return int64_t. display() prints integer.
</action>
  <verify>REPL: findhom([theta3(q,100), theta4(q,100), theta3(q^2,100), theta4(q^2,100)], 2, 0) returns relations. findnonhomcombo(T^2, [T, xi], [1, 7], 0) for Watson returns polynomial.</verify>
  <done>All relation built-ins dispatch; list eval works; Test 5 and Test 8 produce expected relations.</done>
</task>

<task type="auto">
  <name>Task 2: subs_q built-in for theta3(q^2) and Test 5</name>
  <files>src/repl.h</files>
  <action>
Add **subs_q(f, k)** built-in: eval(f) as Series, evalToInt(k). Return f.subs_q(k). The C++ pattern for θ₃(q²) is theta3(q, T).subs_q(2). So findhom uses theta3(subs_q(q,2), 100). Test 5 uses findhom([theta3(q,100), theta4(q,100), theta3(subs_q(q,2),100), theta4(subs_q(q,2),100)], 2, 0).
</action>
  <verify>theta3(subs_q(q,2), 100) or theta3(q^2, 100) if we support q^2 as first arg produces θ₃(q²). findhom with 4 series runs.</verify>
  <done>subs_q built-in or theta3(q^2) handling works; findhom Test 5 passes.</done>
</task>

<task type="auto">
  <name>Task 3: Acceptance test script and 9 SPEC tests</name>
  <files>tests/acceptance.sh, Makefile</files>
  <action>
Create tests/acceptance.sh that pipes REPL commands to qseries and verifies output. **CRITICAL:** Each multi-step test must pipe all commands into a **single** qseries process so variable state persists. Use printf or { echo "cmd1"; echo "cmd2"; } to feed multiple lines to one session.

**Test 1 Rogers-Ramanujan:** printf '%s\n' "rr := sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8)" "prodmake(rr, 40)" | ./qseries.exe | grep -q "1-q" or check for "(q,q^5)" pattern.

**Test 2 Partition:** printf '%s\n' "p := 1/etaq(1,50)" "series(p, 20)" | ./qseries.exe | grep -q "42"

**Test 3 Theta eta:** printf '%s\n' "etamake(theta3(q,100), 100)" | ./qseries.exe | grep -q "η"; printf '%s\n' "etamake(theta4(q,100), 100)" | ./qseries.exe (single-command tests, one session each)

**Test 4 Jacobi RR:** printf '%s\n' "rr := sum(q^(n^2)/aqprod(q,q,n,50), n, 0, 8)" "jacprodmake(rr, 40)" | ./qseries.exe | grep -q "JAC\|(q,q"

**Test 5 Gauss AGM:** printf '%s\n' "findhom([theta3(q,100), theta4(q,100), theta3(subs_q(q,2),100), theta4(subs_q(q,2),100)], 2, 0)" | ./qseries.exe (single command; add subs_q if needed)

**Test 6 Rødseth:** printf '%s\n' "PD := etaq(2,200)/etaq(1,200)" "PD1 := sift(PD,5,1,199)" "etamake(PD1, 38)" | ./qseries.exe

**Test 7 Qfactor:** printf '%s\n' "t8 := T(8,8)" "qfactor(t8, 20)" | ./qseries.exe

**Test 8 Watson:** printf '%s\n' "xi := q^2*etaq(49,100)/etaq(1,100)" "T := q*(etaq(7,100)/etaq(1,100))^4" "findnonhomcombo(T^2, [T, xi], [1, 7], 0)" | ./qseries.exe (T is user var; REPL truncation is set_trunc, separate)

**Test 9 Euler:** printf '%s\n' "EULER := etaq(1,500)" "E0 := sift(EULER,5,0,499)" "jacprodmake(E0,50)" | ./qseries.exe

Script should exit 0 if all pass, non-zero otherwise. Add to Makefile: acceptance: qseries.exe tests/acceptance.sh (run script).
</action>
  <verify>make acceptance (or ./tests/acceptance.sh) runs all 9 tests; exit 0 when all pass.</verify>
  <done>All 9 SPEC acceptance tests pass via acceptance.sh.</done>
</task>

</tasks>

<verification>
- All 9 SPEC tests pass (Rogers-Ramanujan, Partition, Theta/eta, Jacobi RR, Gauss AGM, Rødseth, Qfactor, Watson, Euler pentagonal)
- findhom, findnonhomcombo produce expected relations
- acceptance.sh exits 0
</verification>

<success_criteria>
- Relation built-ins complete
- subs_q(f,k) or equivalent for theta3(q^2)
- 9 SPEC acceptance tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/10-repl/10-03-SUMMARY.md`
</output>
