---
phase: 10-repl
plan: 02
type: execute
wave: 2
depends_on: [10-01]
files_modified:
  - src/repl.h
autonomous: true

must_haves:
  truths:
    - "aqprod, etaq, theta2/3/4, prodmake, etamake, jacprodmake, sift, qfactor, T(r,n) dispatch correctly"
    - "sum/add loops with sumIndices; q^(n^2)/aqprod(q,q,n,50) in sum body works"
    - "q injection: etaq(1,50) and theta3(100) work (q supplied from env)"
  artifacts:
    - path: src/repl.h
      provides: Built-in dispatch for qfuncs and convert
      contains: "dispatchBuiltin", "aqprod", "etaq", "prodmake", "sum"
  key_links:
    - from: src/repl.h
      to: src/qfuncs.h
      via: aqprod, etaq, theta2/3/4, qbin
      pattern: "aqprod|etaq|theta"
    - from: src/repl.h
      to: src/convert.h
      via: prodmake, etamake, jacprodmake, sift, qfactor, T_rn, jac2prod
      pattern: "prodmake|etamake|jacprodmake"
    - from: src/repl.h eval
      to: sum body
      via: sumIndices overlay for loop variable
      pattern: "sumIndices|sumVar"
---

<objective>
Implement built-in dispatch in repl.h for qfuncs (aqprod, etaq, theta2/3/4, theta, qbin, tripleprod, quinprod, winquist), convert (prodmake, etamake, jacprodmake, sift, qfactor, T), and sum/add. Apply q-injection when arg count is one less than C++ (e.g. etaq(1,50)→etaq(q,1,50)). Handle jac2prod(var) for variables holding jacprodmake result.

Purpose: Rogers-Ramanujan (Test 1), Partition (Test 2), Theta/eta (Test 3), Jacobi RR (Test 4), Qfactor (Test 7), Sifting (Test 6), Euler (Test 9) can run through REPL.
Output: Complete qfuncs + convert dispatch; sum/add with sumIndices
</objective>

<execution_context>
@C:/Users/ggarv/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/ggarv/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-repl/10-CONTEXT.md
@.planning/phases/10-repl/10-RESEARCH.md
@src/parser.h
@src/qfuncs.h
@src/convert.h
@.planning/phases/10-repl/10-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: q-injection and qfuncs dispatch (aqprod, etaq, theta, qbin, etc.)</name>
  <files>src/repl.h</files>
  <action>
Add dispatchBuiltin(callName, args, env, sumIndices, T) in repl.h. For each built-in:

**q-injection rule** (per 10-RESEARCH): If C++ API takes (q, ...) and user provides 1 fewer arg, prepend env["q"]. Examples: etaq(1,50)→etaq(q,1,50); theta3(100)→theta3(q,100); theta4(100)→theta4(q,100); qbin(m,n,T) has 3 args → qbin(q,m,n,T) with q from env.

**Built-ins returning Series:**
- aqprod(a, q, n, T): eval a,q as Series; evalToInt(n), evalToInt(T). Call aqprod(eval(a), eval(q), n, T).
- etaq: (k,T) or (q,k,T). 2 args → inject q, call etaq(q,k,T).
- theta2, theta3, theta4: (T) or (q,T). 1 arg → inject q.
- theta(z,T) or (z,q,T): 2 args → inject q.
- qbin: (m,n,T) or (q,m,n,T). 3 args → inject q.
- tripleprod(z,q,T), quinprod(z,q,T), winquist(a,b,q,T): eval all args.
- sift(f,n,k,T): eval(f), evalToInt(n,k,T).

**T(r,n)** — built-in T(r,n) or T(r,n,T): calls T_rn(evalToInt(r), evalToInt(n), T). Use current env T.
</action>
  <verify>REPL: etaq(1,50) returns Series; theta3(100) returns theta3; aqprod(q,q,5,50) returns (q;q)_5.</verify>
  <done>etaq, theta2/3/4, aqprod, qbin, sift, T dispatch and return correct Series.</done>
</task>

<task type="auto">
  <name>Task 2: convert built-ins (prodmake, etamake, jacprodmake, jac2prod, qfactor)</name>
  <files>src/repl.h</files>
  <action>
**prodmake(f, T)** — eval(f) as Series, evalToInt(T). Call prodmake(f, T). Return std::map&lt;int,Frac&gt; (ProdmakeResult). display() calls formatProdmake.

**etamake(f, T)** — eval(f), evalToInt(T). Call etamake(f, T). Return vector&lt;pair&lt;int,Frac&gt;&gt;. display() calls formatEtamake.

**jacprodmake(f, T)** — eval(f), evalToInt(T). Return vector&lt;JacFactor&gt;. display() calls jac2prod(jac). Store in env: user may assign jp:=jacprodmake(x,40); later jac2prod(jp). EnvValue holds variant Series | vector&lt;JacFactor&gt; so assignment works.

**jac2prod(var)** — 1 arg: eval as Var. Lookup env[name]. If holds vector&lt;JacFactor&gt;, call jac2prod(it) and return DisplayOnly string. If Series, throw "jac2prod expects jacprodmake result".

**qfactor(f, T)** — eval(f), evalToInt(T) or use default T if T omitted. Return QFactorResult. display() calls formatQfactor.

**series(f, T?)** — display only. eval(f), truncate to T or default, call f.str(maxTerms). No stored value.

**coeffs(f, from, to)** — display only. eval(f), evalToInt(from, to). Print coeffList(from,to).

**set_trunc(N)** — evalToInt(N). T = N; env["q"] = Series::q(T). Return std::monostate (no display).
</action>
  <verify>REPL: rr:=sum(q^(n^2)/aqprod(q,q,n,50),n,0,8); prodmake(rr,40) shows product; jacprodmake(rr,40) shows JAC form; jp:=jacprodmake(rr,40); jac2prod(jp) works.</verify>
  <done>prodmake, etamake, jacprodmake, jac2prod(var), qfactor, series, coeffs, set_trunc work.</done>
</task>

<task type="auto">
  <name>Task 3: sum/add with sumIndices</name>
  <files>src/repl.h</files>
  <action>
For Expr::Tag::Sum (from sum(body, var, lo, hi) or add(...)):

1. lo_val = evalToInt(lo), hi_val = evalToInt(hi). Bounds must be integers.
2. Create sumIndices_local = sumIndices (copy); for n = lo_val to hi_val: sumIndices_local[var] = n.
3. For each n: eval(body, env, sumIndices_local). The body may contain Var(var) — when eval sees Var and var in sumIndices, return Series::constant(Frac(n), T) so q^(n^2) becomes q^(n²) via BinOp(Pow, Q, BinOp(Pow, Var("n"), 2)): exponent evalToInt(Pow(Var,2)) = n².
4. For BinOp(Pow, base, exp): if base is Q (or base is Var-in-sumIndices as constant — actually Var in sum body is the index; for q^n the base is Q), then exponent must be integer. Use evalToInt(exp) with sumIndices. Return Series::qpow(expVal, T).
5. Accumulate: result = zero(T); for n=lo..hi: result += eval(body); result.trunc = T.
6. Return result.

**aqprod in sum body**: aqprod(q,q,n,50) — the third arg is Var("n"). evalToInt(Var("n")) with sumIndices["n"]=n returns n. So aqprod gets n correctly.
</action>
  <verify>REPL: sum(q^(n^2)/aqprod(q,q,n,50),n,0,8) returns Rogers-Ramanujan series; prodmake on it yields denominators at ±1 mod 5.</verify>
  <done>sum/add evaluates correctly; Rogers-Ramanujan sum produces expected series.</done>
</task>

</tasks>

<verification>
- Rogers-Ramanujan: rr:=sum(q^(n^2)/aqprod(q,q,n,50),n,0,8); prodmake(rr,40) — denominators only at n≡±1 (mod 5)
- Partition: p:=1/etaq(1,50); series(p,20) — coeffs 1,1,2,3,5,7,11,15,22,30,42
- Jacobi RR: jacprodmake(rr,40) — JAC(0,5,∞)/JAC(1,5,∞)
</verification>

<success_criteria>
- All qfuncs and convert built-ins dispatch
- sum/add with sumIndices produces correct Rogers-Ramanujan
- q injection works for etaq, theta*
</success_criteria>

<output>
After completion, create `.planning/phases/10-repl/10-02-SUMMARY.md`
</output>
