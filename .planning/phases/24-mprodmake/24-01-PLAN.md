---
phase: 24-mprodmake
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/convert.h
  - src/repl.h
  - tests/acceptance-mprodmake.sh
autonomous: true

must_haves:
  truths:
    - "mprodmake(ep,17) returns (1+q)(1+q³)(1+q⁵)...(1+q¹⁷) for ep = etaq(2,T)^2/etaq(4,T)/etaq(1,T)"
    - "mprodmake fails with stderr and empty result when f is not an m-product"
    - "mprodmake displays '1' for constant-1 series"
  artifacts:
    - path: src/convert.h
      provides: mprodmake(f,T) function
      contains: "mprodmake"
    - path: src/repl.h
      provides: formatMprodmake, display handler, mprodmake dispatch, help entry
      contains: "formatMprodmake"
  key_links:
    - from: src/repl.h dispatch
      to: src/convert.h mprodmake
      via: "mprodmake(ev(0), evi(1))"
      pattern: "mprodmake\\(ev"
---

<objective>
Implement mprodmake: convert q-series to product (1+q^n1)(1+q^n2)..., matching Maple qseries API.

Purpose: Close gap from FEATURE-GAPS; enable identification of eta^2/eta/eta quotients as ∏(1+q^n) products.

Output: mprodmake in convert.h; formatMprodmake, dispatch, help, display in repl.h; acceptance test script.
</objective>

<execution_context>
Execute with fresh context. Build: g++ -std=c++20 -O2 -static -o qseries main.cpp (or make).
</execution_context>

<context>
@.planning/phases/24-mprodmake/24-RESEARCH.md
@.planning/phases/24-mprodmake/24-CONTEXT.md
@src/convert.h
@src/repl.h
@src/series.h
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement mprodmake in convert.h</name>
  <files>src/convert.h</files>
  <action>
Add inline function mprodmake(f, T) after prodmake (around line 122).

Signature: std::vector&lt;int&gt; mprodmake(const Series&amp; f, int T)

Algorithm (per CONTEXT, locked):
1. Normalize: g = f.truncTo(T); fail if g.coeff(0).isZero() or g.minExp() &gt; 0 (stderr "mprodmake: b[0]=0 or no constant term", return {}).
2. Divide g by lead so b[0]=1 (same as prodmake).
3. auto a = prodmake(g, T); if a.empty() return {}.
4. Check: for each (n, an) in a: an must be integer and an ∈ {-1,0,1}; else stderr "mprodmake: not an m-product", return {}.
5. S = {n : a[n]=1} ∪ {n : a[2n]=-1}. Use std::set or collect into vector and std::sort.
6. Return sorted std::vector&lt;int&gt; of exponents.

Edge: constant 1 → prodmake returns empty or all zeros → S = {} → return {} (caller displays "1").
  </action>
  <verify>
Build succeeds. Manual: ep = etaq(2,100)^2/etaq(4,100)/etaq(1,100); mprodmake(ep,17) in REPL.
  </verify>
  <done>mprodmake exists in convert.h; returns sorted exponents or {} on failure.</done>
</task>

<task type="auto">
  <name>Task 2: formatMprodmake, EvalResult, display, dispatch, help in repl.h</name>
  <files>src/repl.h</files>
  <action>
1. Add std::vector&lt;int&gt; to EvalResult variant (line ~124, after std::map&lt;int,Frac&gt;).
2. Add formatMprodmake(const std::vector&lt;int&gt;&amp; S): if S.empty() return "1"; else build "(1+q)(1+q³)..." using Series::expToUnicode(n) for each exponent; n=1 → "(1+q)", n&gt;1 → "(1+q" + expToUnicode(n) + ")".
3. In display(), add visitor case for std::vector&lt;int&gt;: std::cout &lt;&lt; formatMprodmake(arg).
4. In dispatchBuiltin: if (name == "mprodmake") { args.size()==2; return mprodmake(ev(0), evi(1)); }
5. In getHelpTable(): {"mprodmake", {"mprodmake(f,T)", "convert series to product (1+q^n1)(1+q^n2)..."}}
  </action>
  <verify>
Build succeeds. REPL: mprodmake(etaq(2,100)^2/etaq(4,100)/etaq(1,100), 17) prints (1+q)(1+q³)...(1+q¹⁷). help(mprodmake) prints signature and description.
  </verify>
  <done>mprodmake built-in works; formatMprodmake produces Maple-style output; help entry exists.</done>
</task>

<task type="auto">
  <name>Task 3: Acceptance test for mprodmake</name>
  <files>tests/acceptance-mprodmake.sh</files>
  <action>
Create tests/acceptance-mprodmake.sh:

1. Same BIN resolution as acceptance-wins.sh (dist/qseries.exe, qseries, etc.).
2. run() helper: printf inputs | "$BIN" 2&gt;&amp;1
3. Test 1: ep := etaq(2,100)^2/etaq(4,100)/etaq(1,100); mprodmake(ep,17) — expect output containing (1+q)(1+q³) and (1+q¹⁷) (grep for "1\+q" and "1\+q¹⁷" or similar; use expToUnicode ¹⁷ = ⁹⁷ pattern or simpler: grep for "1+q" and "17" or match the full product).
4. Simpler: grep -q "(1+q)(1+q³)" and grep -q "(1+q¹⁷)" — exponent 17 in unicode is ¹⁷. Check for "(1+q¹⁷)".
5. Test 2: mprodmake(1, 10) or mprodmake(Series::one) — expect "1" (empty S → formatMprodmake → "1").
6. Make script executable (chmod +x) and run it.

Use REPL syntax: "ep := etaq(2,100)^2/etaq(4,100)/etaq(1,100)" "mprodmake(ep,17)" as two lines.
  </action>
  <verify>
./tests/acceptance-mprodmake.sh exits 0; all tests pass.
  </verify>
  <done>Acceptance test passes; mprodmake(ep,17) produces expected product; constant 1 produces "1".</done>
</task>

</tasks>

<verification>
- Build: make dist/qseries.exe or g++ -std=c++20 -O2 -o qseries main.cpp
- Run: echo -e "ep := etaq(2,100)^2/etaq(4,100)/etaq(1,100)\nmprodmake(ep,17)" | ./qseries
- Expected: output contains (1+q)(1+q³)(1+q⁵)...(1+q¹⁷)
</verification>

<success_criteria>
- mprodmake(etaq(2,T)^2/etaq(4,T)/etaq(1,T), 17) displays (1+q)(1+q³)(1+q⁵)(1+q⁷)(1+q⁹)(1+q¹¹)(1+q¹³)(1+q¹⁵)(1+q¹⁷)
- Non-m-product series fails with stderr message
- Constant 1 displays "1"
- help(mprodmake) shows mprodmake(f,T) and description
- tests/acceptance-mprodmake.sh exits 0
</success_criteria>

<output>
After completion, create .planning/phases/24-mprodmake/24-01-SUMMARY.md
</output>
